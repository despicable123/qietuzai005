###  HTML
##### 取消\<a>标签默认跳转行为
onclick = "return false" 或者 \<a href="javascript:void(0)" ></a>
###  CSS
##### 移动端：响应式布局，页面自适应
*用比例控制大小*
在网页代码的头部，加入一行viewport元标签
`<meta name="viewport" content="width=device-width, initial-scale=1.0">`
以下是相关的属性的解释：
width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）
height：和 width 相对应，指定高度
initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例，1.0就是占网页的100%
maximum-scale：允许用户缩放到的最大比例
minimum-scale：允许用户缩放到的最小比例
user-scalable：用户是否可以手动缩放
2. 用百分比去写元素的宽度，不要写绝对宽度
3. 让子元素撑起父元素的高度，而不要写绝对高度
4. 字体使用相对大小 "em"** 或 "rem" 
5. 图片的大小也用百分比表示
*媒体查询* (CSS3 @media 查询)
`当网页需要在移动端和PC端展示时，由于二者屏幕尺寸差别较大，可能需要用两种不同的布局才能更加友好地展示内容
此时可以使用媒体查询来检测屏幕(或浏览器窗口)的大小，然后采用相应的css样式来渲染页面`
```css
@media screen and (max-width: 767px) {
    body {
        width: 100%
    }
}
```
100%
750
970
1170

```js
function refreshRem() {
    var docEl = doc.documentElement;
    var width = docEl.getBoundingClientRect().width;
    var rem = width / 10;
    docEl.style.fontSize = rem + 'px';
    flexible.rem = win.rem = rem;
}
win.addEventListener('resize', refreshRem);

```
rem布局的缺点：
在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前，可放在head里面第一个script标签（默认情况下html元素的font-size为16px，即1rem=16px）

vm/vh 

##### CSS 自适应两栏布局（注意要求高度也自适应）
父元素 overflow：hidden  子元素 float：left padding-bottom：999999px  margin-bottom：-999999px
父元素 display：table 子元素 display：table-cell
父元素 display：flex  子元素 flex：1（等宽）


### JS
##### undefined 跟 null
null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0
##### for of
它接受迭代器，包括数组，字符串，Set，Map，DOM集合
它接受类数组对象
迭代的项目可以在就地解构。
##### 数组操作方法
1. join()
功能：将数组中所有元素都转化为字符串并连接在一起。

2. reverse()
功能：将数组中的元素颠倒顺序。

3. concat()
功能：数组拼接的功能 ,返回新数组，原数组不受影响。

4. slice()
截取数组生成新数组，原数组不受影响。
返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定位置之间的所有元素。如果为负数，表示相对于数组中最后一个元素的位置。如果只有一个参数，表示到数组末尾。
```js
var aa = [1,2,3,4,5,6];
console.log(aa.slice(2)); //[3,4,5,6]
console.log(aa.slice(2,8)); //[3,4,5,6] 超过最大长度，只显示到最后结果
console.log(aa.slice(2,5)); //[3,4,5]
console.log(aa.slice(2,-1)); //[3,4,5] 相对于倒数第一个之前
console.log(aa.slice(2,-2)); //[3,4] 相对于倒数第二个之前
console.log(aa.slice(3)); //[4,5,6] 一个参数从第三个到最后
console.log(aa.slice(-2));//[5,6] 一个参数负值从倒数第二个到最后
负数index在第一个参数的时候包括本身，在第二个参数的时候不包括本身
```

5. splice()
功能：从数组中删除元素、插入元素到数组中或者同时完成这两种操作。
输入：第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。之后的参数表示需要插入到数组中的元素 。如果只有一个参数，默认删除参数后边的所有元素。
输出：返回一个由删除元素组成的数组。
注意：新建了一个数组，并修改了原数组
```js
var aa = [1,2,3,4,5,6];
console.log(aa.splice(4)); //[5,6]  返回删除后的数组
aa; // [1,2,3,4]
console.log(aa.splice(2,2)); //[3,4] 从第二位起删除两个元素
aa; //[1,2]
console.log(aa.splice(1,0,7,8)); //[]从第一位起删除0个元素，添加7,8到原数组
aa;//[1,7,8,2]
```
6. push()
在数组末尾添加一个或多个元素，并返回新数组长度
7. pop()
从数组末尾删除1个元素(删且只删除1个), 并返回 被删除的元素
8. unshift()
在数组开始添加一个或多个元素，并返回新数组长度
9. shift()
在数组开始删除一个元素(删且只删除1个),并返回 被删除的元素
10. toString()和toLocaleString()
将数组的每个元素转化为字符串，并且输入用逗号分隔的字符串列表。功能类似join();
11. ndexOf()和lastIndexOf()
indexOf() 两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。没找到返回-1. 返回查找项的索引值
lastIndexOf() 从数组的末尾开始向前查找。返回查找项的索引值(索引值永远是正序的索引值),没找到返回-1
12. sort();
默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。所以用默认方法排序数据是有问题的。

当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。
对于长度大于1000的数组，采用的是快排与插入排序混合的方式进行排序的，因为，当数据量很小的时候，插入排序效率优于快排。

快排的平均时间复杂度是nlogn，在排序算法中属于效率最高的。快排是一种不稳定的排序算法，但是一般情况下稳定或者不稳定对我们没有特别大的影响，但是对稳定性要求高的排序，就不能使用快排了。

```js
var arr = [20,10,2,1,3];
arr.sort();// [1, 10, 2, 20, 3]
arr.sort(function(a,b){
  return a-b;    //升序
}); //[1, 2, 3, 10, 20]
arr.sort(function(a,b){
  return b-a;    //降序
}); //[20,10,3,2,1]
```
快排
```js
function quickSort(arr,left=0,right=arr.length-1){
  let partIndex
  if (left < right) {
      partIndex = part(arr,left,right)
      quickSort(arr,left,partIndex-1)
      quickSort(arr,partIndex+1,right)
  }
  
  return arr
}
function part(arr,left,right){
  let base = left
  let index = left + 1
  for(let i = index; i<= right; i++){
      if(arr[i]<arr[base]){
          [arr[i],arr[index]]=[arr[index],arr[i]]
          index++
      }
  }
  [arr[base],arr[index-1]] = [arr[index-1],arr[base]]
  return index-1
}
```
插入排序
```js
function insertSort(arr){
    for(let i = 1; i<arr.length;i++){
        let j = i - 1
        let temp = arr[i] 
        while(j >= 0 && arr[j] > temp){
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = temp
    }
    return arr
}
```
13. forEach()
从头至尾遍历数组，为每个元素调用指定函数
输入为一个待遍历函数，函数的参数依次为：数组元素、元素的索引、数组本身
forEach和map
两者都属于js数组Array的方法，用于遍历数组，高级浏览器支持，区别在于，forEach()方法没有返回值，只是遍历数组，而map方法会返回数组的每一项，但不改变原数组，相当于返回原数组的一个修改过的副本。
##### 对象操作方法（object静态方法）
1. Object.create()
2. Object.defineProperty(object, prop, descriptor)
3. Object.defineProperties()
```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});

```
4. keys 遍历可枚举的属性，只包含对象本身可枚举属性，不包含原型链可枚举属性
5. values 遍历可枚举的属性值，只包含对象本身可枚举属性值，不包含原型链可枚举属性值
6. Object.assign( target, source, source1 ) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）
7. getPrototypeOf 获取指定对象的原型（内部\[[Prototype]]属性的值）
8. setPrototypeOf 设置一个指定的对象的原型
9. getOwnPropertyNames 与keys相似，但包含遍历包含不可枚举属性
10. getOwnPropertyDescriptor 获取该属性的描述对象
11. getOwnPropertyDescriptors 返回指定对象所有自身属性（非继承属性）的描述对象
12. entries 分割对象
13. is 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致
```js
Object.is('foo', 'foo')     // true

Object.is({}, {})           // false

不同于 === 之处
+0 === -0                   //true
NaN === NaN                     // false

Object.is(+0, -0)           // false
Object.is(NaN, NaN)         // true
```
14. hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性
15. isPrototypeOf用于测试一个对象是否存在于另一个对象的原型链上
##### Promise的理解
微任务包括：MutationObserver、Promise.then()或catch()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。
宏任务包括：script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering

### 计算机网络
##### 跨域
跨域问题其实就是浏览器的同源策略所导致的。协议、域名、端口号保持一致
1. CORS
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器「不同的域、协议或端口」请求一个资源时，资源会发起一个「跨域 HTTP 请求」。
而在 cors 中会有 简单请求 和 复杂请求的概念。
a.简单请求
不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：
情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)

GETHEADPOST
情况二: 人为设置以下集合外的请求头

`Accept Accept-Language Content-Language Content-Type` （需要注意额外的限制）`DPR Downlink Save-Data Viewport-Width Width`
情况三：`Content-Type`的值仅限于下列三者之一：(例如 `application/json` 为非简单请求)

`text/plain multipart/form-data application/x-www-form-urlencoded`
情况四:
请求中的任意`XMLHttpRequestUpload `对象均没有注册任何事件监听器；`XMLHttpRequestUpload` 对象可以使用` XMLHttpRequest.upload` 属性访问。
情况五:
请求中没有使用` ReadableStream `对象。
b.非简单请求
除以上情况外的。
Node 中的解决方案
```js
ctx.set("Access-Control-Allow-Origin", ctx.headers.origin);  
ctx.set("Access-Control-Allow-Credentials", true);  
ctx.set("Access-Control-Request-Method", "PUT,POST,GET,DELETE,OPTIONS");  
ctx.set("Access-Control-Allow-Headers","Origin, X-Requested-With,Content-Type, Accept, cc");
```
2. Node正向代理
配置proxy
```js
//proxy(axios)
devServer: {
    port: 8000,
    proxy: {
      "/api": {
        target: "http://localhost:8080"
      }
    }
  },
//生产环境
axios.default.baseUrl='后台接口'
```
3. nignx反向代理
4. jsonp
利用了 script 标签没有跨域限制的这个特性来完成的。
    - 仅支持 GET 方法
    - 前端定义解析函数（例如 jsonpCallback=function(){....}）
    - 通过 params 形式包装请求参数，并且声明执行函数(例如 cb=jsonpCallback)
    - 后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式
    `ctx.body = ${cb}(${JSON.stringify({ msg })});`传递给前端。
前端
```html
<script>  window.jsonpCallback = function(res) {console.log(res);};
</script><script src="http://localhost:8080/api/a.js?a=123&cb=sonpCallback"></script>
// http://localhost:8080/api/a.js jsonpCallback({a:123});
```
5. iframe 可以在 http 返回头 添加X-Frame-Options: SAMEORIGIN 防止被别人添加至 iframe。
6. window.location.hash + Iframe 和 window.name + Iframe都是利用中间同源页面来传递跨域请求


##### 模块化
1. CommonJs最早，用于服务端，同步加载，运行时加载，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。值传递，require相当于把被引用的module拷贝了一份到当前module中，只执行一次之后缓存，每次使用都是用的缓存，如我们现在是在浏览器环境下，在我们还没有完成复制的时候，无法使用被引用的模块中的方法和属性。在服务端可能这不是一个问题(因为服务器的文件都是存放在本地，并且是有缓存的)，但在浏览器环境下，这会导致阻塞，使得我们后面的步骤无法进行下去，还可能会执行一个未定义的方法而导致出错。相对于服务端的模块化，浏览器环境下，模块化的标准必须满足一个新的需求：异步的模块管理。
2. 在这样的背景下，RequireJS (AMD)出现了，require/define,在使用 RequireJS 声明一个模块时，必须指定所有的依赖项 ，这些依赖项会被当做形参传到 factory 中，对于依赖的模块会提前执行（在 RequireJS 2.0 也可以选择延迟执行），这被称为：依赖前置。加大了开发过程中的难度，无论是阅读之前的代码还是编写新的内容，也会出现这样的情况：引入的另一个模块中的内容是条件性执行的。
3. 针对 AMD 规范中可以优化的部分，CMD 规范 出现了，而 SeaJS 则作为它的具体实现之一，与 AMD 十分相似：CMD推崇依赖就近 + 延迟执行,按照 CMD 规范的依赖就近的规则定义一个模块，会导致模块的加载逻辑偏重，有时你并不知道当前模块具体依赖了哪些模块或者说这样的依赖关系并不直观。
而且对于 AMD 和 CMD 来说，都只是适用于浏览器端的规范，而 Node.js module 仅仅适用于服务端，都有各自的局限性。
4. ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。编译完输出接口这种形式，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。import命令具有提升效果，会提升到整个模块的头部，首先执行。ES2020提案 引入import()函数，支持动态加载模块。路由懒加载可以实现，import()返回一个 Promise 对象。运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。

### Vue
##### vue响应式原理
数据驱动视图 UI = render(state) vue扮演的是render这个角色
应用Object.defineProperty给value新增一个__ob__属性，值为该value的Observer实例。这个操作相当于为value打上标记，表示它已经被转化成响应式了，然后开始依赖收集，订阅者Dep收集watcher观察者对象，watcher实例被创建出来之后会挂在到window上，然后get需要使用的数据触发getter，Dep类就会收集这个watcher到subs数组里，等变化了就会调用通知方法挨个通知用到这个对象的属性的watcher去更新，render function渲染出虚拟dom，开始diff

vm.$set 的实现原理
如果目标是数组，直接使用数组的 splice 方法触发相应式；

如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）




##### webpack看法
使用webpack的主要目的就是为了简化项目依赖的管理，它将所有资源看成是一个模块，将所有逻辑代码看成是一个整体，从打包入口着手，将项目所需的依赖通过loader和plugin进行处理，然后输出一个能通过浏览器解析的js代码。webpack主要有四个核心的概念，分别是entry、output、loader和plugin。

entry是指项目打包的入口，在这个入口中找寻所有依赖文件。

output是项目打包的出口，打包成一个兼容性的js代码，默认位置为'./dist'。

loader属于webpack的编译器，是用于处理非JavaScript文件的打包，在对loader进行配置的时候，test用于规定哪些后缀结尾的文件用于打包，内容为正则表达式，use属性用于表示哪个loader用于对test文件进行预处理，常见的有css-loader、style-loader等。

plugins插件可以用于更广范围的功能，比如文件的压缩、优化、搭建服务器等功能。要使用一个插件先用npm安装，然后再添加到配置文件中使用。
##### promise理解
Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。
一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。
##### VueRouter两种模式
为了达到改变视图的同时不会向后端发出请求这一目的，前端路由是不涉及服务器的，是前端利用hash或者HTML5的history API来实现的，一般用于不同内容的展示和切换
hash模式
路由的哈希模式其实是利用了window.onhashchange事件，也就是说你的url中的哈希值（#后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载
```js
window.addEventListener('hashchange', () => {
   // 把改变后的url地址栏的url赋值给data的响应式数据current，调用router-view去加载对应的页面
   this.data.current = window.location.hash.substr(1)
})
```

history模式
HTML5 History Interface 中新增的两个神器 pushState() 和 replaceState() 方法（需要特定浏览器支持），当这两个方法执行修改时，只能改变当前地址栏的 URL，但浏览器不会向后端发送请求，也不会触发popstate事件的执行，用来完成 URL 跳转而无须重新加载页面，不过这种模式还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，就需要前端自己配置404页面。（hash模式只会往后台请求#之后的内容，history是全部，后台没响应的话就报错了）
pushState() 和 replaceState() 这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404（因为浏览器一旦刷新，就是去真正请求服务器资源）
那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效，pushState方法、replaceState方法，只能导致history对象发生变化，从而改变当前地址栏的 URL，但浏览器不会向后端发送请求，也不会触发popstate事件的执行
```js
window.addEventListener('popstate', () => {
  this.data.current = window.location.pathname
})
```
history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
```js
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);

```

调用 history.pushState() 相比于直接修改 hash，存在以下优势:
pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同index的 URL
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中
pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串
pushState() 可额外设置 title 属性供后续使用
history的话
nigix配置要加上 `try_files $uri $uri/ @rewrites` 先去找静态文件，找不到就用@rewrite替代

##### vuex理解
专为 Vue.js 应用程序开发的状态管理模式，解决多个组件共享状态的问题
Vuex 依赖 Promise
Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。
每个应用将仅仅包含一个 store 实例
Mutation 需遵守 Vue 的响应规则
最好提前在你的 store 中初始化好所有所需属性。
当需要在对象上添加新属性时，你应该Vue.set
Mutation 必须是同步函数,因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。
Action 提交的是 mutation，而不是直接变更状态。
Action 可以包含任意异步操作。
store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise,可以利用 async / await

### 操作系统
### 算法
- 字符串转驼峰
```js
function tranformStr1(str){
    var strArr=str.split('-');
    for(var i=1;i<strArr.length;i++){
        strArr[i]=strArr[i].charAt(0).toUpperCase()+strArr[i].substring(1);
    }
    return strArr.join('');
}
```
```js
//正则
function transformStr3(str){
    var re=/-(\w)/g;
    return str.replace(re,function ($0,$1){
        return $1.toUpperCase();
    });
}
```
### get和post区别
1、GET参数通过URL传递，POST放在Request body中。

2、GET请求会被浏览器主动cache，而POST不会，除非手动设置。

3、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

4、Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符。

5、 一般我们在浏览器输入一个网址访问网站都是GET请求

6、HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。

7、GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

8、在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

#### css3新特性
1. border-radius：创建圆角边框
2. box-shadow：为元素添加阴影
3. border-image：使用图片来绘制边框
4. 新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break
5. word-wrap 语法：word-wrap: normal|break-word              normal：使用浏览器默认的换行 break-all：允许在单词内换行
6. text-overflow 设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：clip：修剪文本  ellipsis：显示省略符号来代表被修剪的文本
7. rgba hsla
8. transition
  transition-property: width; 
  transition-duration: 1s;
  transition-timing-function: linear;
  transition-delay: 2s;
9. transform 转换
  transform: translate(120px, 50%)：位移
  transform: scale(2, 0.5)：缩放
  transform: rotate(0.5turn)：旋转
  transform: skew(30deg, 20deg)：倾斜
10. animation 动画
  animation-name：动画名称
  animation-duration：动画持续时间
  animation-timing-function：动画时间函数
  animation-delay：动画延迟时间
  animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环
  animation-direction：动画执行方向
  animation-paly-state：动画播放状态
  animation-fill-mode：动画填充模式
11. flex弹性布局、Grid栅格布局

#### em误区
em就是相对于元素自身font-size的大小。只是若没有对元素显式地使用绝对单位来声明font-size时，该元素font-size属性自动继承自父元素。
```js
function init () {
    // 获取屏幕宽度
    var width = document.documentElement.clientWidth
    // 设置根元素字体大小。此时为宽的10等分
    document.documentElement.style.fontSize = width / 10 + 'px'
}

//首次加载应用，设置一次
init()
// 监听手机旋转的事件的时机，重新设置
window.addEventListener('orientationchange', init)
// 监听手机窗口变化，重新设置
window.addEventListener('resize', init)
```
#### 如何让IE支持html5标签
```js
<!--[if lt IE 9]>
<script>
   (function() {
     if (!
     /*@cc_on!@*/
     0) return;
     var e = "abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video".split(', ');
     var i= e.length;
     while (i--){
         document.createElement(e[i])
     }
})()
</script>
<![endif]-->
```
以上代码放在头部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效）

### 206状态码
206: 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。响应必须包含如下的头部域:Content-Range用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。Date ETag 和/或Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如 ETag 或 Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。任何不支持 Range 以及 Content-Range头的缓存都禁止缓存206响应返回的内容。