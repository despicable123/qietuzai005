---
title: 前端常见算法！！
tags:
	- 前端
	- 算法
---

[TOC]

#### 一.apply/call

```js
Function.prototype.call = function(context){
    context = context ? Object(context):window;
    context.fn = this;
    let args = [];
    for (let i = 1; i < arguments.length; i++){
        args.push('arguments['+i+']');
    }
    let r = eval('context.fn('+args')');
    delete context.fn;
    return r;
}
```

```js
Function.prototype.apply = function (context, arr) {
  //判断是否为一个对象，如果不是，则转换成对象
  context = context ? Object(context) : window;
  let result;
  context.fn = this;
  //如果函数后面没有跟参数，则直接执行
  if (!arr) {
    result = context.fn();
  } else {
    let args = [];
    for (let i = 0; i < arr.length; i++) {
      args.push("arr[" + i + "]");
    }
    //eval会把后面的代码当做js来解释
    result = eval("context.fn(" + args + ")");
  }
  delete context.fn;
  return result;
};
```

#### 二 .bind

更换 this 指向，同时返回一个函数，函数可以作为实例函数返回，也可以作为构造函数进行 new 实例化

```js
Function.prototype.bind = function (context) {
  //如果调用的不是一个方法
  if (typeof this !== "function") {
    throw new Error("what is trying to be bound is not callable");
  }
  //先将方法获取过来
  let self = this;
  //这个是通过数组切割获取第一个对象参数
  let args = Array.prototype.slice.call(arguments, 1);
  //创造一个空对象作为中转
  var o = function () {};
  var newf = function () {
    //后面的参数接收过来
    let arr = Array.prototype.slice.call(arguments);
    //判断是否是构造方法，如果是构造方法，就把this指向new出来的对象，如果不是就是用原来的
    return self.call(this instanceof newf ? this : context, args.concat(arr));
  };
  //将调用方法的原型赋给空对象的原型
  o.prototype = this.prototype;
  //通过构造函数，通过原型链即可访问到this方法里的属性和对象
  newf.prototype = new o();
  return newf;
};
```

#### 三.new 函数

主要做三件事

1. 创建一个全新的对象，这个对象的**proto**要指向构造函数的原型对象
2. 执行构造函数
3. 返回值为 object 类型则作为 new 方法的返回值返回，否则返回上述全新对象

```js
function objnew() {
  //返回的对象
  let obj = {};
  //调用shift函数将第一个参数对象截出来，就是我们的构造函数对象
  Construstor = [].shift.call(arguments);
  //将obj的隐式原型指向构造函数的显式原型
  obj.__proto__ = Construstor.prototype;
  //调用构造函数的构造方法，并把参数传进去
  let r = Construstor.apply(obj, arguments);
  //返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象
  return typeof r === "object" ? r : obj;
}
```

#### 四 用 ES5 实现数组的 map 函数

1. 循环遍历数组，并返回一个新数组
2. 回调函数一共接收 3 个参数，分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」

```js
Array.prototype.map = function (fn) {
  let arr = [];
  for (let i = 0; i < this.length; i++) {
    arr.push(fn(this[i]));
  }
  return arr;
};
```

#### 五 用 ES5 实现数组的 filter 函数

1. 该方法返回一个由通过测试的元素组成的新数组，如果没有通过测试的元素，则返回一个空数组
2. 回调函数一共接收 3 个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」

```js
Array.prototype.filter = function (fn) {
  let arr = [];
  for (let i = 0; i < this.length; i++) {
    if (fn(this[i])) {
      arr.push(this[i]);
    }
  }
  return arr;
};
```

#### 六 用 ES5 实现数组的 some 函数

1. 在数组中查找元素，如果找到一个符合条件的元素就返回 true，如果所有元素都不符合条件就返回 false；
2. 回调函数一共接收 3 个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」。

```js
Array.prototype.some = function (fn) {
  let flag = false;
  for (let i = 0; i < this.length; i++) {
    if (fn(this[i])) {
      flag = true;
    }
  }
  return flag;
};
```

#### 七、用 ES5 实现数组的 every 方法

检测一个数组中的元素是否都能符合条件，都符合条件返回 true，有一个不符合则返回 false

如果收到一个空数组，此方法在任何情况下都会返回 true

回调函数一共接收 3 个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」

```js
Array.prototype.every = function(fn){
  for (let i = 0; i < this.length; i++){
     f(!fn(this[i])){
        return false;
     }
  }
    return true;
}
```

#### 八、用 ES5 实现数组的 find 方法

在数组中查找元素，如果找到符合条件的元素就返回这个元素，如果没有符合条件的元素就返回 undefined，且找到后不会继续查找

回调函数一共接收 3 个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」

```js
Array.prototype.find = function (fn) {
  for (let i = 0; i < this.length; i++) {
    if (fn(this[i])) {
      return this[i];
    }
  }
};
```

#### 九、用 ES5 实现数组的 forEach 方法

1. 循环遍历数组，该方法没有返回值
2. 回调函数一共接收 3 个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」

```js
Array.prototype.forEach = function (fn) {
  for (let i = 0; i < this.length; i++) {
    fn(this[i], i, this);
  }
};
```

#### 十、用 ES5 实现数组的 reduce 方法

- 特点：

1. 初始值不传时的特殊处理：会默认用数组中的第一个元素
2. 函数的返回结果会作为下一次循环的 prev
3. 回调函数一共接收 4 个参数，分别是「上一次调用回调时返回的值、正在处理的元素、正在处理的元素的索引，正在遍历的集合对象」。

```js
Array.prototype.reduce = function (fn, prev) {
  for (let i = 0; i < this.length; i++) {
    if (typeof prev === "undefind") {
      prev = fn(this[i], this[i + 1], i + 1, this);
      ++i;
    } else {
      prev = fn(prev, this[i], i, this);
    }
  }
};
```

#### 十一、实现 instanceof 方法

- 特点：

沿着原型链的向上查找，直到找到原型的最顶端，也就是`Object.prototype`。查找构造函数的 prototype 属性是否出现在某个实例对象的原型链上，如果找到了返回 true，没找到返回 false。

```js
function myinstanceof(left, right) {
  left = left.__proto__;
  while (true) {
    if (left === null) {
      return false;
    } else if (left == right.prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
```

#### 十二、实现 Object.create 方法(经常考)

创建一个新对象，使用现有的对象来提供新创建的对象的**proto**

```js
function creat(proto) {
  //创建新的对象的构造函数
  function Fn() {}
  Fn.prototype = proto;
  Fn.prototype.constructor = Fn;
  return new Fn();
}
```

#### 十三、实现一个通用的柯里化函数

柯里化就是将一个函数的功能细化，把接受「多个参数」的函数变换成接受一个「单一参数」的函数，并且返回接受「余下参数」返回结果的一种应用。

1. 判断传递的参数是否达到执行函数的 fn 个数
2. 没有达到的话，继续返回新的函数，将 fn 函数继续返回并将剩余参数累加
3. 达到 fn 参数个数时，将累加后的参数传给 fn 执行

```js
const curring = (fn, arr = []) => {
  let len = fn.length;
  return function (...args) {
    arr = [...arr, ...args];
    if (arr.length < len) {
      return curring(fn, arr);
    } else {
      return fn(...arr);
    }
  };
};
```

#### 十四、实现一个反柯里化函数

- 特点：

使用`call`、`apply`可以让非数组借用一些其他类型的函数，比如，`Array.prototype.push.call`, `Array.prototype.slice.call`， `uncrrying`把这些方法泛化出来，不在只单单的用于数组，更好的语义化。

```js
Function.prototype.uncurry = function () {
  let self = this;
  return function () {
    return Function.prototype.call.apply(self, arguments);
  };
};
```

#### 十五、实现一个简单的节流函数(throttle)

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

节流重在加锁`flag = false`

```js
const throttle = (fn, delay) => {
  let flag = true;
  return (...args) => {
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(this, args);
      flag = true;
    }, delay);
  };
};
```

#### 十六、实现一个简单的防抖函数(debounce)

在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时

防抖重在清零`clearTimeout(timer)`

```js
const debounce = (fn, delay) => {
  let timer = null;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
};
```

#### 十七、实现一个 Pipe （管道）

将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。该函数调用的方向是从左至右的（先执行 sum，再执行 toUpper，再执行 add）

```js
function Pipe(...fns) {
  return (...args) => {
    let lastFn = fns.shift();
    return fns.reduceRight((a, b) => {
      return b(a);
    }, lastFn(...args));
  };
}
```

#### 十八、实现一个 Compose (组合)

将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。该函数调用的方向是从右至左的（先执行 sum，再执行 toUpper，再执行

```js
const compose = (...fns) => {
  return (...args) => {
    let lastFn = fns.pop();
    return fns.reduceRight((a, b) => {
      return b(a);
    }, lastFn(...args));
  };
};
```

#### 十九 . 实现数组去重

##### 1. 使用 filter 方法

```js
let arr = ["banana", "apple", "orange", "lemon", "apple", "lemon"];
function RemoveSameData(data) {
  return data.filter((value, index) => {
    data.indexof(value) == index;
  });
}
```

##### 2.使用 ES6 的 Set

Set 是 ES6 中的新对象类型，用于创建唯一 key 的集合。

```js
let arr = ["banana", "apple", "orange", "lemon", "apple", "lemon"];
function RemoveSameData(data) {
  return [...new Set(data)];
}
```

##### 3. 使用 forEach 方法

forEach 方法可以遍历数组中的元素，如果该元素不在数组中，就将该元素 push 到数组中。

```js
let arr = ["banana", "apple", "orange", "lemon", "apple", "lemon"];
function RemoveSameData(data) {
  let unique = [];
  data.forEach((element) => {
    if (!unique.includes(element)) {
      unique.push(element);
    }
  });
  return unique;
}
```

#### 二十 实现数组的取交集，并集，差集

##### 1.取交集

```js
let a = [1, 2, 3];
let b = [2, 4, 5];
const inter = a.filter((value) => b.includes(value));
```

```js
let a = [1, 2, 3];
let b = [2, 4, 5];
const inter = a.filter((value) => b.indexof(value) > -1);
```

##### 2. 取并集

**Array.prototype.includes**

```js
let a = [1, 2, 3];
let b = [2, 4, 5];
const inter = a.concat(b.filter((value) => !a.include(value)));
```

##### 3. 取差集

```js
let a = [1, 2, 3];
let b = [2, 4, 5];
const inter = a
  .concat(b)
  .filter((value) => !a.includes(value) || !b.includes(value));
```

#### 二十一 实现观察者模式

**观察者模式** 是基于发布订阅模式的，分为`观察者`和`被观察者`两部分，需要被观察者先收集观察者，当被观察者的状态改变时通知观察者。**观察者和被观察者之间存在关系，被观察者数据发生变化时直接通知观察者改变。**

![image-20210329114953582](E:\blog\img\image-20210329114953582.png)

```js
class Subject {
  constructor(name) {
    this.name = name;
    this.state = "正常的";
    this.observer = [];
  }
  attach(key, o) {
    this.observer.push(o);
  }

  setstate(newstate) {
    this.state = newstate;
    this.observer.forEach((o) => o.update(this));
  }
}
class Observer {
  constructor(name) {
    this.name = name;
  }
  update(baby) {
    console.log(this.name + "被通知了,被观察者状态是" + baby.state);
  }
}
let baby = new Subject("小宝宝");
let father = new Observer("爸爸");
let mother = new Observer("妈妈");

baby.attach(father);
baby.attach(mother);
baby.setState("我饿了");
```

#### 二十二 实现发布订阅者模式

![image-20210329115005470](E:\blog\img\image-20210329115005470.png)

```js
let event = {
  list: {}, //监听队列
  //监听
  on(key, fn) {
    if (!this.list[key]) {
      this.list[key] = [];
    }
    this.list[key].push(fn);
  },
  //触发
  emit() {
    let key = [].shift.call(arguments);
    fns = this.list[key];
    if (!fns || fns.length == 0) {
      return false;
    }
    fns.forEach((fn) => {
      fn.apply(this, arguments);
    });
  },
  //取消订阅
  remove(key, fn) {
    let fns = this.list[key];
    if (!fns) return false;
    if (!fn) {
      fns && (fns.length = 0);
    } else {
      fns.forEach((item, i) => {
        if (item == fn) {
          fns.splice(i, 1);
        }
      });
    }
  },
};
function cat() {
  console.log("一起喵喵喵");
}
function dog() {
  console.log("一起旺旺旺");
}

event.on("pet", (data) => {
  console.log("接收数据");
  console.log(data);
});
event.on("pet", cat);
event.on("pet", dog);
// 取消dog方法的订阅
event.remove("pet", dog);
// 发布
event.emit("pet", ["二哈", "波斯猫"]);
```

#### 二十三 实现 Promise

```js
const PENDING = "PENDING";
const FULFILLED = "FULFILLED";
const REJECTED = "REJECTED";
class Promise {
  constructor(executor) {
    this.state = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks = [];
    let resolve = (value) => {
      if (this.state === PENDING) {
        this.state = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };
    let reject = (reason) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then(onFulfilled, onRejected) {
    if (this.state === FULFILLED) {
      onFulfilled(this.value);
    }

    if (this.state === REJECTED) {
      onRejected(this.reason);
    }
    if (this.state === PENDING) {
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value);
      });
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason);
      });
    }
  }
}
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("成功");
  }, 5000);
}).then(
  (data) => {
    console.log("success", data);
  },
  (err) => {
    console.log("faild", err);
  }
);
```

实现链式调用

```js
const resolvePromise = (oldPromise, newPromise, resolve, reject) => {
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise
  if (oldPromise === newPromise) {
    return reject(new TypeError("不能自己等自己，错误！"));
  }
  //只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if (
    (typeof newPromise === "object" && newPromise != null) ||
    typeof newPromise == "function"
  ) {
    try {
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）
      let then = newPromise.then;
      if (typeof then === "function") {
        then.call(
          newPromise,
          (s) => {
            if (called) return;
            called = true;
            // 递归解析的过程（因为可能 promise 中还有 promise）
            resolvePromise(newPromise, y, resolve, reject);
          },
          (r) => {
            // 只要失败就失败
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果
        resolve(newPromise);
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 如果 x 是个普通值就直接返回 resolve 作为结果
    resolve(newPromise);
  }
};

const PENDING = "PENDING";
const FULFILLED = "FULFILLED";
const REJECTED = "REJECTED";
class Promise {
  constructor(executor) {
    this.state = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks = [];
    let resolve = (value) => {
      if (this.state === PENDING) {
        this.state = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };
    let reject = (reason) => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (v) => v;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (err) => {
            throw err;
          };
    let newPromise = new Promise((resolve, reject) => {
      if (this.state === FULFILLED) {
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(newPromise, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      }
      if (this.state === REJECTED) {
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(newPromise, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      }
      if (this.state === PENDING) {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
      }
    });

    return newPromise;
  }
}
const promise = new Promise((resolve, reject) => {
  reject("失败");
})
  .then()
  .then()
  .then(
    (data) => {
      console.log(data);
    },
    (err) => {
      console.log("err", err);
    }
  );
```

实现 promise.all 方法

```js
Promise.all = function (values) {
  if (!Array.isArray(values)) {
    return new TypeError("type error");
  }
  return new Promise((resolve, reject) => {
    let resultArr = [];
    let orderindex = 0;
    const processResultBykey = (value, index) => {
      resultArr[index] = value;
      if (++orderindex == values.length) {
        resolve(resultArr);
      }
    };
    for (let i = 0; i < values.length; i++) {
      let value = values[i];
      if (value && typeof value.then === "function") {
        value.then((value) => {
          processResultBykey(value, i);
        }, reject);
      } else {
        processResultBykey(value, i);
      }
    }
  });
};
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("ok1");
  }, 1000);
});

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("ok2");
  }, 1000);
});

Promise.all([1, 2, 3, p1, p2]).then(
  (data) => {
    console.log("resolve", data);
  },
  (err) => {
    console.log("reject", err);
  }
);
```

#### 二十四 实现深拷贝

```js
function deepClone(obj) {
  // 先把特殊情况全部过滤掉 null undefined date reg
  if (obj == null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (typeof obj != "object") return obj;
  // 不直接创建空对象的目的：克隆的结果和之前保持相同的所属类，
  // 同时也兼容了数组的情况
  let newObj = new obj.constructor();
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 不拷贝原型链上的属性
      newObj[key] = deepClone(obj[key]); //递归赋值
    }
  }
  return newObj;
}
```

```js
//克服循环引用
function deepClone(obj, map = new Map()) {
  if (obj == null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (typeof obj !== "object") return obj;
  let newObj = new obj.constructor();
  if (map.get(obj)) {
    return map.get(obj);
  } else {
    map.set(obj, newObj);
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepClone(obj[key], map);
    }
  }
  return newObj;
}
```
