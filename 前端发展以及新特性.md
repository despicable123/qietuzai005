### 微前端
代码库更小，更内聚、可维护性更高
松耦合、自治的团队可扩展性更好
渐进地升级、更新甚至重写部分前端功能成为了可能

简单、松耦合的代码库
比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发
此外，更重要的是避免模块间不合理的隐式耦合造成的复杂度上升。通过界定清晰的应用边界来降低意外耦合的可能性，增加子应用间逻辑耦合的成本，促使开发者明确数据和事件在应用程序中的流向

增量升级
理想的代码自然是模块清晰、依赖明确、易于扩展、便于维护的……然而，实践中出于各式各样的原因：
历史项目，祖传代码
交付压力，当时求快
就近就熟，当时求稳……
总存在一些不那么理想的代码：
所以，为了实施渐进式重构，我们需要一种增量升级的能力，先让新旧代码和谐共存，再逐步转化旧代码，直到整个重构完成
这种增量升级的能力意味着我们能够对产品功能进行低风险的局部替换，包括升级依赖项、更替架构、UI 改版等。另一方面，也带来了技术选型上的灵活性，有助于新技术、新交互模式的实验性试错

独立部署
独立部署的能力在微前端体系中至关重要，能够缩小变更范围，进而降低相关风险
因此，每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），并且要能独立部署，不必过多考虑其它代码库和交付流水线的当前状态：

##### 实现方案
多 Bundle 集成
微前端架构中一般会有个容器应用（container application）将各子应用集成起来，职责如下：
渲染公共的页面元素，比如 header、footer
解决横切关注点（cross-cutting concerns），如身份验证和导航
将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机
集成方式分为 3 类：
服务端集成：如 SSR 拼装模板，如何保证各部分模板（各个微前端）能够独立发布
构建时集成：如 Code Splitting，将子应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle
运行时集成：如通过 iframe、JS(前端路由)、Web Components 等方式,前端路由，每个子应用暴露出渲染函数，主应用在启动时加载各个子应用的独立 Bundle，之后根据路由规则渲染相应的子应用。

影响隔离
子应用之间，以及子应用与主应用间的样式、作用域隔离是必须要考虑的问题，常见解决方案如下：
样式隔离：开发规范（如BEM）、CSS 预处理（如SASS）、模块定义（如CSS Module）、用 JS 来写（CSS-in-JS）、以及shadow DOM特性
作用域隔离：各种模块定义（如ES Module、AMD、Common Module、UMD）

资源复用
应用间通信
测试 :除单元测试、功能测试外，还要有集成测试

###### 缺点
流量负担
独立构建意味着公共资源的冗余，继而增加用户的流量负担
操作/管理上的复杂性
针对各式各样的前端代码库，如何建立质量标准？