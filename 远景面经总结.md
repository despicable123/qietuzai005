### 1. HTML
### 2. CSS
##### 移动端：响应式布局，页面自适应
*用比例控制大小*
在网页代码的头部，加入一行viewport元标签
`<meta name="viewport" content="width=device-width, initial-scale=1.0">`
以下是相关的属性的解释：
width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）
height：和 width 相对应，指定高度
initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例，1.0就是占网页的100%
maximum-scale：允许用户缩放到的最大比例
minimum-scale：允许用户缩放到的最小比例
user-scalable：用户是否可以手动缩放
2. 用百分比去写元素的宽度，不要写绝对宽度
3. 让子元素撑起父元素的高度，而不要写绝对高度
4. 字体使用相对大小 "em"** 或 "rem" 
5. 图片的大小也用百分比表示
*媒体查询* (CSS3 @media 查询)
`当网页需要在移动端和PC端展示时，由于二者屏幕尺寸差别较大，可能需要用两种不同的布局才能更加友好地展示内容
此时可以使用媒体查询来检测屏幕(或浏览器窗口)的大小，然后采用相应的css样式来渲染页面`
```css
@media screen and (max-width: 767px) {
    body {
        width: 100%
    }
}
```
100%
750
970
1170

```js
function refreshRem() {
    var docEl = doc.documentElement;
    var width = docEl.getBoundingClientRect().width;
    var rem = width / 10;
    docEl.style.fontSize = rem + 'px';
    flexible.rem = win.rem = rem;
}
win.addEventListener('resize', refreshRem);

```
rem布局的缺点：
在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前，可放在head里面第一个script标签（默认情况下html元素的font-size为16px，即1rem=16px）

vm/vh 

##### CSS 自适应两栏布局（注意要求高度也自适应）
父元素 overflow：hidden  子元素 float：left padding-bottom：999999px  margin-bottom：-999999px
父元素 display：table 子元素 display：table-cell
父元素 display：flex  子元素 flex：1（等宽）


### JS
##### 数组操作方法
1. join()
功能：将数组中所有元素都转化为字符串并连接在一起。

2. reverse()
功能：将数组中的元素颠倒顺序。

3. concat()
功能：数组拼接的功能 ,返回新数组，原数组不受影响。

4. slice()
截取数组生成新数组，原数组不受影响。
返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定位置之间的所有元素。如果为负数，表示相对于数组中最后一个元素的位置。如果只有一个参数，表示到数组末尾。
```js
var aa = [1,2,3,4,5,6];
console.log(aa.slice(2)); //[3,4,5,6]
console.log(aa.slice(2,8)); //[3,4,5,6] 超过最大长度，只显示到最后结果
console.log(aa.slice(2,5)); //[3,4,5]
console.log(aa.slice(2,-1)); //[3,4,5] 相对于倒数第一个之前
console.log(aa.slice(2,-2)); //[3,4] 相对于倒数第二个之前
console.log(aa.slice(3)); //[4,5,6] 一个参数从第三个到最后
console.log(aa.slice(-2));//[5,6] 一个参数负值从倒数第二个到最后
负数index在第一个参数的时候包括本身，在第二个参数的时候不包括本身
```

5. splice()
功能：从数组中删除元素、插入元素到数组中或者同时完成这两种操作。
输入：第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。之后的参数表示需要插入到数组中的元素 。如果只有一个参数，默认删除参数后边的所有元素。
输出：返回一个由删除元素组成的数组。
注意：新建了一个数组，并修改了原数组
```js
var aa = [1,2,3,4,5,6];
console.log(aa.splice(4)); //[5,6]  返回删除后的数组
aa; // [1,2,3,4]
console.log(aa.splice(2,2)); //[3,4] 从第二位起删除两个元素
aa; //[1,2]
console.log(aa.splice(1,0,7,8)); //[]从第一位起删除0个元素，添加7,8到原数组
aa;//[1,7,8,2]
```
6. push()
在数组末尾添加一个或多个元素，并返回新数组长度
7. pop()
从数组末尾删除1个元素(删且只删除1个), 并返回 被删除的元素
8. unshift()
在数组开始添加一个或多个元素，并返回新数组长度
9. shift()
在数组开始删除一个元素(删且只删除1个),并返回 被删除的元素
10. toString()和toLocaleString()
将数组的每个元素转化为字符串，并且输入用逗号分隔的字符串列表。功能类似join();
11. ndexOf()和lastIndexOf()
indexOf() 两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。没找到返回-1. 返回查找项的索引值
lastIndexOf() 从数组的末尾开始向前查找。返回查找项的索引值(索引值永远是正序的索引值),没找到返回-1
12. sort();
默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。所以用默认方法排序数据是有问题的。

当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。
对于长度大于1000的数组，采用的是快排与插入排序混合的方式进行排序的，因为，当数据量很小的时候，插入排序效率优于快排。

快排的平均时间复杂度是nlogn，在排序算法中属于效率最高的。快排是一种不稳定的排序算法，但是一般情况下稳定或者不稳定对我们没有特别大的影响，但是对稳定性要求高的排序，就不能使用快排了。

```js
var arr = [20,10,2,1,3];
arr.sort();// [1, 10, 2, 20, 3]
arr.sort(function(a,b){
  return a-b;    //升序
}); //[1, 2, 3, 10, 20]
arr.sort(function(a,b){
  return b-a;    //降序
}); //[20,10,3,2,1]
```
快排
```js
function quickSort(arr,left=0,right=arr.length-1){
  let partIndex
  if (left < right) {
      partIndex = part(arr,left,right)
      quickSort(arr,left,partIndex-1)
      quickSort(arr,partIndex+1,right)
  }
  
  return arr
}
function part(arr,left,right){
  let base = left
  let index = left + 1
  for(let i = index; i<= right; i++){
      if(arr[i]<arr[base]){
          [arr[i],arr[index]]=[arr[index],arr[i]]
          index++
      }
  }
  [arr[base],arr[index-1]] = [arr[index-1],arr[base]]
  return index-1
}
```
插入排序
```js
function insertSort(arr){
    for(let i = 1; i<arr.length;i++){
        let j = i - 1
        let temp = arr[i] 
        while(j >= 0 && arr[j] > temp){
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = temp
    }
    return arr
}
```
13. forEach()
从头至尾遍历数组，为每个元素调用指定函数
输入为一个待遍历函数，函数的参数依次为：数组元素、元素的索引、数组本身
forEach和map
两者都属于js数组Array的方法，用于遍历数组，高级浏览器支持，区别在于，forEach()方法没有返回值，只是遍历数组，而map方法会返回数组的每一项，但不改变原数组，相当于返回原数组的一个修改过的副本。
##### 对象操作方法（object静态方法）
1. Object.create()
2. Object.defineProperty(object, prop, descriptor)
3. Object.defineProperties()
```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});

```
4. keys 遍历可枚举的属性，只包含对象本身可枚举属性，不包含原型链可枚举属性
5. values 遍历可枚举的属性值，只包含对象本身可枚举属性值，不包含原型链可枚举属性值
6. Object.assign( target, source, source1 ) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）
7. getPrototypeOf 获取指定对象的原型（内部\[[Prototype]]属性的值）
8. setPrototypeOf 设置一个指定的对象的原型
9. getOwnPropertyNames 与keys相似，但包含遍历包含不可枚举属性
10. getOwnPropertyDescriptor 获取该属性的描述对象
11. getOwnPropertyDescriptors 返回指定对象所有自身属性（非继承属性）的描述对象
12. entries 分割对象
13. is 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致
```js
Object.is('foo', 'foo')     // true

Object.is({}, {})           // false

不同于 === 之处
+0 === -0                   //true
NaN === NaN                     // false

Object.is(+0, -0)           // false
Object.is(NaN, NaN)         // true
```
14. hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性
15. isPrototypeOf用于测试一个对象是否存在于另一个对象的原型链上
##### Promise的理解
微任务包括：MutationObserver、Promise.then()或catch()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。
宏任务包括：script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering

### 计算机网络
##### 跨域
跨域问题其实就是浏览器的同源策略所导致的。协议、域名、端口号保持一致
1. CORS
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器「不同的域、协议或端口」请求一个资源时，资源会发起一个「跨域 HTTP 请求」。
而在 cors 中会有 简单请求 和 复杂请求的概念。
a.简单请求
不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：
情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)

GETHEADPOST
情况二: 人为设置以下集合外的请求头

`Accept Accept-Language Content-Language Content-Type` （需要注意额外的限制）`DPR Downlink Save-Data Viewport-Width Width`
情况三：`Content-Type`的值仅限于下列三者之一：(例如 `application/json` 为非简单请求)

`text/plain multipart/form-data application/x-www-form-urlencoded`
情况四:
请求中的任意`XMLHttpRequestUpload `对象均没有注册任何事件监听器；`XMLHttpRequestUpload` 对象可以使用` XMLHttpRequest.upload` 属性访问。
情况五:
请求中没有使用` ReadableStream `对象。
b.非简单请求
除以上情况外的。
Node 中的解决方案
```js
ctx.set("Access-Control-Allow-Origin", ctx.headers.origin);  
ctx.set("Access-Control-Allow-Credentials", true);  
ctx.set("Access-Control-Request-Method", "PUT,POST,GET,DELETE,OPTIONS");  
ctx.set("Access-Control-Allow-Headers","Origin, X-Requested-With,Content-Type, Accept, cc");
```
2. Node正向代理
配置proxy
```js
//proxy(axios)
devServer: {
    port: 8000,
    proxy: {
      "/api": {
        target: "http://localhost:8080"
      }
    }
  },
//生产环境
axios.default.baseUrl='后台接口'
```
3. nignx反向代理

##### 模块化
1. CommonJs最早，用于服务端，同步加载，运行时加载，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。值传递，require相当于把被引用的module拷贝了一份到当前module中，只执行一次之后缓存，每次使用都是用的缓存，如我们现在是在浏览器环境下，在我们还没有完成复制的时候，无法使用被引用的模块中的方法和属性。在服务端可能这不是一个问题(因为服务器的文件都是存放在本地，并且是有缓存的)，但在浏览器环境下，这会导致阻塞，使得我们后面的步骤无法进行下去，还可能会执行一个未定义的方法而导致出错。相对于服务端的模块化，浏览器环境下，模块化的标准必须满足一个新的需求：异步的模块管理。
2. 在这样的背景下，RequireJS (AMD)出现了，require/define,在使用 RequireJS 声明一个模块时，必须指定所有的依赖项 ，这些依赖项会被当做形参传到 factory 中，对于依赖的模块会提前执行（在 RequireJS 2.0 也可以选择延迟执行），这被称为：依赖前置。加大了开发过程中的难度，无论是阅读之前的代码还是编写新的内容，也会出现这样的情况：引入的另一个模块中的内容是条件性执行的。
3. 针对 AMD 规范中可以优化的部分，CMD 规范 出现了，而 SeaJS 则作为它的具体实现之一，与 AMD 十分相似：CMD推崇依赖就近 + 延迟执行,按照 CMD 规范的依赖就近的规则定义一个模块，会导致模块的加载逻辑偏重，有时你并不知道当前模块具体依赖了哪些模块或者说这样的依赖关系并不直观。
而且对于 AMD 和 CMD 来说，都只是适用于浏览器端的规范，而 Node.js module 仅仅适用于服务端，都有各自的局限性。
4. ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。编译完输出接口这种形式，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。import命令具有提升效果，会提升到整个模块的头部，首先执行。ES2020提案 引入import()函数，支持动态加载模块。路由懒加载可以实现，import()返回一个 Promise 对象。运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。

### 操作系统
### 算法
- 字符串转驼峰
```js
function tranformStr1(str){
    var strArr=str.split('-');
    for(var i=1;i<strArr.length;i++){
        strArr[i]=strArr[i].charAt(0).toUpperCase()+strArr[i].substring(1);
    }
    return strArr.join('');
}
```
```js
//正则
function transformStr3(str){
    var re=/-(\w)/g;
    return str.replace(re,function ($0,$1){
        return $1.toUpperCase();
    });
}
```