## 防抖节流
- 本质上是优化高频率执行代码的一种手段
- 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
- 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率
- 定义：节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次执行    场景：resize、scroll、mousemove
        防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时  场景：实时搜索联想
# 节流
```js
// 用来返回节流函数的工具函数
function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        //不传递this的话会丢失this指向
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn.apply(context, args), remaining);
        }
    }
}
```

# 防抖
```js
function debounce(calllback, delay) {
  return function() {
    //启动定时器，只是准备真正处理
    if(callback.hasOwnProperty('timeoutId'){
      clearTimeout(callback.timeoutId)
    })
    callback.timeoutId = setTimeout(()=>{
      callback.apply(this,arguments)
      //标记事件已经正在处理
      delete callback.timeoutId // 或者 clearTimeout(callback.timeoutId)
    },delay)
  }
}
```

## webpack
- 一切文件皆为模块，都有依赖关系
- 从入口文件开始，递归找到所有文件依赖模块，内部构建一个依赖图，依赖图会映射项目所需的每个模块，并生成一个或多个bundle文件
- webpack与webpack-cli在4.0之后的区别（webpack做js的打包工作，-cli解析webpack命令，命令内部使用webpack功能）
- webpack不用全局下载，只需要局部下载即可：原因公司多个项目可能使用不同版本的webpack
- 使用npx webpack使用局部webpack进行打包，
- 使用npm script运行的webpack命令默认先找的是局部的webpack
- webpack本身能解析打包各种模块规范的js代码（ES6、CommonJS、AMD、CMD）
- 核心概念（模式、入口、输出、加载器、插件）
### 处理
1. loader处理
2. plugin处理
3. devtool
4. devSever
### 搭建环境
1. 基础环境
2. vue环境
3. react环境

## XSS（跨站脚本攻击）
1. 通过html注入篡改了网页，插入了恶意的脚本，反射型xss、存储型xss、dom based xss
2. XSS payload，xss攻击成功后往页面植入恶意脚本，这些脚本被称为xss payload，常见的是通过读取浏览器的cookie对象，发起cookie劫持，构造get post请求、构造技巧，利用字符编码，window.name可以跨域，为了绕过长度限制，藏代码最好地方是location.hash，用eval执行
3. 防御xss：httpOnly，服务器返回时发送Set-Cookie头，向客户端写入Cookie，httpOnly在此时标记，不允许客户端脚本访问。输入输出检查。

## CSRF （跨站点请求伪造）
1. 诱使用户访问一个页面，以该用户身份在第三方站点里执行一次操作，伪造请求这种攻击就叫做跨站点请求伪造。
2. 浏览器Cookie策略，两种Cookie：Session Cookie（临时Cookie，保存浏览器进程的内存空间）和Third-party Cookie（本地Cookie，保存在本地）
3. 本地Cookie设置了过期时间，到期才失效，临时Cookie关浏览器就没了，ie禁止浏览器在img、iframe、script、link标签中发送本地Cookie，但是p3p头允许跨域设置Cookie，p3p策略是一一对应的
4. CSRF的防御：
   - 验证码：CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码强制用户和应用进行交互，才能完成最终请求。但是不能给所有请求都加验证码，是一种辅助手段。
   - Refer Check：最常见的应用是防止图片盗链，用于检查请求是否来自合法的源，比如论坛发帖操作，提交发帖表单时，Refer值必然时发帖表单所在的页面，如果refer值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。缺陷在于，服务器并非上面时候都能取到referer，很多用户处于隐私保护的考虑，限制了refer的发送，在某些情况下，比如HTTPS跳转HTTP，出于安全考虑，浏览器不会发送Refer。
   - token：要真随机数，尽量存在服务器端的session中，防止出现在referer中，用POST请求，此方案仅用于对抗CSRF，如果网站还存在XSS漏洞token会被访问到然后再构造除一个合法的请求，这个过程可以称为XSRF。

## Oath
1. A网站想获取用户在B平台的信息，引导用户访问B平台的授权页面。
2. 用户同意授权后重定向至A网站，A后台获取一个code，拿code去B平台换取access_token和用户id，access_ token和用户id去换取用户信息。


## cookie、session、jwt、token
1. http是无状态的，上面的方式其实都是为了让客户端-服务端进行有状态的对话。
2. cookie+session坏处是session存在内存中，服务端重启后所有用户都需要重新登录。浏览器禁用cookie之后回造成用户会话永久失效，因为发起请求中没有cookie，服务端无法识别用户，用nignx做负载均衡集群的时候，登录session存在a服务器，请求发到b服务器去的时候就无法验证，需要用户重新登录，虽然可以用ip hash解决这个问题，但是负载均衡就失去意义了。好处是浏览器都内置了对cookie seesion的处理，不需要后端及前端开发人员理解交互逻辑，一个api即可完成认证，服务端可以控制cookie+session机制的有效会话事件
3. cookie+session更适合于单体web服务，在前后端不分离的项目用的比较多。
4. jwt
   - 优点是无状态去中心化的，支持移动设备，支持跨程序调用，cookie是不允许跨域访问的，加密特性保证了token不可伪造和篡改。
   - 缺点是jwt仅在生成时支持失效时间，失效时间固定，不可主动失效，不可存储大量信息。

##### 1.js基本数据类型
js的基本数据类型有字符型、数值型、布尔值、null、undefined和es6新增的symbol。symbol主要作用是给变量提供唯一的标识，可以解决全局变量冲突的问题。
##### 2.JavaScript 有几种类型的值？你能画一下他们的内存图吗？
栈：基本数据类型

堆：引用数据类型

两者区别在三个方面：

声明变量时不同内存位置不同：基本数据类型变量的值储存在栈中，这是因为基本数据类型占据的空间内存是固定的，因此可以直接访问。引用数据类型储存在栈中的是变量的地址指针，指向堆中的引用。因为引用数据类型的大小会改变因此不能储存在栈中会影响查找的速率。

访问机制不同：在JavaScript中是不允许直接访问储存在堆内存中的变量的，能够访问的是堆内存中的地址，然后按照地址去访问引用类型，而栈中的数据变量是可以直接访问到的。

复制变量时不同：栈中的变量复制时会将数值保存为另一个副本，这两者是相互独立的。而堆中的对象进行复制时是将保存着内存地址的变量赋值给另一个变量，两者引用地址相同，它们中任何一个进行修改时都会改变另一个变量。

传递参数时不同：传递参数是将变量的值传递给形参，引用数据类型中的值为该变量在堆内存中的地址，因此将引用数据类型作为参数传递时在函数内部对变量进行修改会影响函数外部该引用数据的值。
##### 3.什么是堆？什么是栈？它们之间有什么区别和联系？
栈和堆的概念来自于从数据结构和操作系统中。

数据结构中栈为先进后出队列，而堆为优先级队列，二叉树为典型的堆队列。

操作系统中栈区内存由编译器自动释放，主要储存函数的参数、局部变量等，结束后自动销毁。堆区内存主要靠程序员手动释放，若没有手动释放，垃圾回收机制会将其回收。
##### 4.内部属性 [&#91;Class]] 是什么？
所有用typeof返回为object的变量都含有一个内部属性[&#91;Class]]，可以看成是内部的分类，利用Object.prototype.toString.call()可返回该分类。

例如Object.prototype.toString.call([]) 返回[&#91;Object Array]]
##### 5.介绍 js 有哪些内置对象？
js中的内置对象指的是在操作前由js定义的存在于全局作用域中的全局值属性、函数对象、以及可实例化的构造函数。全局值属性例如NaN、null等，函数有parseInt、parseFloat等，可实例化其他对象的构造函数Number、Boolean、Function等以及还有Date、数学对象Math等。
##### 6.undefined 与 undeclared 的区别？
已在全局中声明但还没有赋值的变量返回undefined，未声明的变量是undeclared。会报错返回is not defined。
#####  7.null 和 undefined 的区别？
null表示这个值被定义了但是这个值是空值，是对象原型链的终点，undefined表示缺值。Number(null)输出为0, Number(undefined)输出为NaN

首先null和undefined都是基本数据类型。

undefined表示变量未定义，null代表的含义是空对象，一般变量未定义的时候会返回undefined，null一般作为变量对象的初始值。

typeof null 会返回object。null == undefined 返回true，但三个等号返回false。
##### 8.如何获取安全的 undefined 值？
表达式void _ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。
按惯例我们用void 0来获得 undefined。
##### 9.说几条写 JavaScript 的基本规范？
在日常书写JavaScript代码时应该遵循一些基本规范利于读者阅读以及日后维护。例如：

变量声明尽量放在作用域的前面，并且var声明时最好给予初始值。

用===和!&#61;=来代替&#61;=和！=。

不要给内置对象的原型对象上添加方法，例如Array，Object，Function等。

代码中出现地址、时间等常量用变量来代替。

switch语句必须带有default分支。

if和for语句要有大括号。
##### 10.JavaScript 原型，原型链？ 有什么特点？
在JavaScript中我们使用构造函数创建一个实例对象时，每个构造函数内部都有一个prototype属性，这个属性是一个对象，即原型对象。实例对象内部的 proto 属性指向构造函数的原型对象，并且该原型对象也可看成其他构造函数的实例，这个proto属性链就是原型链。当我们要查找实例对象身上的某个属性及方法时，若该实例对象身上没有，可沿着proto属性一级一级向上找，直至Object.prototype。

特点：JavaScript中是利用引用来进行传递的，当我们修改了某一原型的属性时，所有继承都会被修改。
##### 11.js 获取原型的方法？
- P.constructor.prototype
- Object.getPrototypeOf(P)
- P.proto
##### 12.在 js 中不同进制数字的表示方式
- 以 0X、0x 开头的表示为十六进制。
- 以 0、0O、0o 开头的表示为八进制。
- 以 0B、0b 开头的表示为二进制格式。
#####  13.js 中整数的安全范围是多少？
JS 中所有的数字类型，实际存储都是通过 8 字节 double 浮点型 表示的。安全整数指的是该整数转换为二进制时精度不会丢失。最大值指的是2的53次幂-1，超过安全整数范围在计算时会有误差。在ES6中被定义为Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER。当超过整数范围时会返回infinity。
##### 14.typeof NaN 的结果是什么？
typeof NaN会返回number。NaN是一个特殊值，它与自身不相等，NaN !=NaN 为true
#####  15.isNaN 和 Number.isNaN 函数的区别？
isNaN接收参数时会尝试将其转化为数值型再判断，因此传入的不能转换为数值的会返回true，但非数值型也会返回true，影响了NaN的判断。

Number.isNaN会先判断其是否为Number，然后在进行isNaN判断。判断更为准确。
##### 16.Array 构造函数只有一个参数值时的表现？
Array构造函数只有一个参数值时会让其视为创建数组的长度length值，而非充当一个元素。但创建出来的数组依然是个空数组，但有预设长度值。
##### 17.其他值到数字值的转换规则？
undefined返回NaN。
null返回0.
true返回1，false返回0.
字符串类型的值转换为数值型如同利用Number()，若字符串中含有非数字型返回NaN，空字符串返回0.
##### 18.其他值到布尔类型的值的转换规则？
转换为false的有六种：
null、undefined、false、""、NaN、+0、-0
#####  19.{} 和 [] 的 valueOf 和 toString 的结果是什么？
{}的valueOf为{}，toString为[Object Object]
[] 的valueOf为 [], toString为“”
##### 20.什么是假值对象？
在某些情况下，浏览器在一些常规的JavaScript基础上自行创建的一些对象，这些对象强制转换为布尔值时为false，例如document.all为一个伪数组，表示页面中所有元素的数组，由DOM提供给JavaScript使用。
##### 21.~ 操作符的作用？
~表示按位取反，~~可以用于取整。
##### 22.解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？
解析字符串中的数字允许含有非数字，例如parseInt解析字符串时会返回开头的数值，若第一个字符为非数字，则返回NaN，而Number（）解析字符串时字符中不能含有不合法字符。否则返回NaN.
##### 23.其他值到字符串的转换规则？
toString（）
##### 24.+ 操作符什么时候用于字符串的拼接？
当+操作符前后两个变量至少一个为字符串时，两者用+连接为字符串拼接。若两者都为数字，则会数字加法运算。而除了+以外的其他运算符，只要其中一方为数字，另一方就会转换为数字。
##### 25. 什么情况下会发生布尔值的隐式强制类型转换？
例如在if语句中进行判断时会转换为布尔值，还有while语句。三项表达式。for（ ； ； ）中的第二项。逻辑运算符||和&&进行判断时。
##### 26. || 和 && 操作符的返回值？
首先会对第一项进行布尔值强制类型转换。

运用||运算符时，当第一项为true，则直接返回true，当第一项为false，则返回第二项的布尔值

运动&&运算符时，当第一项为true，则返回第二项的布尔值，当第一项为false，则直接返回false。
##### 27.Symbol 值的强制类型转换？
symbol值可以进行显性类型转换 但不能进行隐形类型转换 会报错。
symbol值不能转换为数值型，但可以转化为布尔值，不管是显性还是隐性都是true。
##### 28. == 操作符的强制类型转换规则？
- 字符串和数值型进行==比较时，将字符串转换为数值型再进行比较。
- 其他类型跟布尔值进行比较时，先将布尔值转换为数值型，再进行其他比较。
- NaN和本身取==时为false
- null == undefined 为true
- 如果两个操作值都是对象，则需比较两者是否为同一个引用对象。
##### 29. 如何将字符串转化为数字，例如 '12.3b'?
- 使用Number（）方法，但前提是所包含的字符串不包含不合法字符。
- parseInt（）方法，取整。
- parseFloat（）方法，浮点数
- 隐式类型转换
##### 30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?
使用正则表达式方法
```js
function format(number)
{  return number && number.replace(/(\d)(?=(\d{3}+\.))/g, function($1, $2, $3){  return $2 + ',';  }) }
```
?=pattern 表示匹配到pattern的开始位置的字符，例如window(?=95|98|2000|xp)，可以匹配到window2000中的window。
##### 31. 常用正则表达式
##### 32.生成随机数的各种方法？
Math.random() 生成[0, 1) 范围内的随机浮点数。
##### 33. 如何实现数组的随机排序？
1. 随机抽取下标
```js
  function randomsort(arr){  
    var newarr = [];  
    while(arr.length > 0){   
      var index = Math.floor(Math.random()*arr.length);   
      newarr.push(arr[index]);   
      arr.splice(index, 1);  
    }
    return newarr; 
  }
```
2. 洗牌法
```js
  function randomsort(arr){  
    let leng = arr.length,  
    tempindex;  
    for(var i = 0; i < leng; i++){  
      tempindex = Math.floor(Math.random()*(leng - i) + i);  
      [arr[i],arr[tempindex]] = [arr[tempindex],arr[i]] 
    }  
    return arr; 
  }
```
##### 34. javascript 创建对象的几种方式？
1. 字面量
2. 工厂模式
```js
// 工厂函数
function createPerson ( name, age ) {
    var object = new Object();
    object.name = name;
    object.age = age;
    object.getName = function(){
        return object.name;
    }
    return object;
}
```
3. 构造函数模式
```js
function Person( name, age ) {
    this.name = name;
    this.age = age;
    this.getName = function(){ 
        return this.name;
    };
}
```
4. 原型模式
```js
function Dog(){}
  Dog.prototype.name="旺财";
  Dog.prototype.eat=function(){
  alert(this.name+"是个吃货");
  }
  var wangcai =new Dog();
  wangcai.eat();
```
5. 混合模式
```js
function Car(name,price){
  this.name=name;
  this.price=price; 
  }
  Car.prototype.sell=function(){
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
  var camry =new Car("凯美瑞",27);
  camry.sell();
```
##### 35.JavaScript 继承的几种实现方式？
1. 原型链继承
- 将子构造函数的原型对象指向父构造函数的实例对象，那么子构造函数的实例对象可继承父类上的属性及方法。缺点是创建子类时不能向父类传参，并且父类原型上的所有引用类型可应用到所有实例对象上。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
  } 
  Father.prototype.getName = function(){  
    return this.name; 
  } 
  function Child(skill){  
    this.skill = skill; 
  } 
  Child.prototype = new Father('zhangsan', 20); 
  var child = new Child('dance'); 
  console.log(child.getName());
```

2. 盗用构造函数继承
- 通过在子类中使用对父构造函数使用call方法来调用，并且修改this指针指向子类，同时可以传递参数。优点：避免了引用类型的属性被所有实例共享，也解决了不能传参的问题。缺点是因为方法都在构造函数中定义了，因此每次创建实例时都要创建一遍方法。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age;  
  this.getName = function(){   return this.name;  }  
  this.getAge = function(){   return this.age;  } 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.getName())
```

3. 组合继承
- 结合原型链继承和盗用构造函数继承，二者优点集中起来
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
} 
Father.prototype.money = function(){  
  console.log('100000'); 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill; 
} 
Child.prototype = new Father(); 
Child.prototype.constructor = Child; 
Child.prototype.exam = function(){  
  console.log('i want to have an exam');
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.money())
```
4. 原型式继承
- 原则上只是进行了一次浅复制，适合不需要单独创建构造函数的场合，但仍然需要在对象间共享信息，包含的引用值时终会在相关对象间共享，跟使用原型模式是一样的。es5增加了Object.creat()方法等同于下面函数。
```js
function creatObj(o){  
  function F(){};  
  F.prototype = o;  
  return new F(); 
} 
  var person = {  name: 'zhangsan',  age: 20 } 
  var person1 = creatObj(person); 
  var person2 = creatObj(person); 
  person1.name = 'lisi'; 
  console.log(person1.name, person2.name);
```
5. 寄生式继承
- 类似原型式继承，创建了一个封装继承过程的函数，该函数在内部以某种方式来增强对象，在考虑对象不是自定义类型和构造函数的情况下，寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。
```js
function object(o){
    function F() {}
    F.prototype = o;
    return new F();
}
function createAnother(original){
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式来增强这个对象
        console.log("Hi");
    };
    return clone; //返回这个对象
}
var person = {
    name:"李白",
    friends:["杜甫","陆游"]
};
var anotherPerson = createAnother(person)
anotherPerson.sayHi();//Hi
```
6. 寄生式组合继承
- 寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。“寄生组合继承”用了“寄生继承”修复了“组合继承”的小bug，让js完美实现继承了。
```js
// 实现继承的简单方法
function object(o){
function F () {};
F.prototype = o;
return new F();
}
// 寄生继承
function inheritPrototype(subType, superType){
  var prototype = object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}
function testObject() {
var A = function(){}, 
B = function(){}, a, b;
inheritPrototype(B, A)
}
```

##### 37.Javascript 的作用域链？
作用域链是保证执行函数时变量对象的有序访问，是指向变量对象的有序列表，变量对象包含执行函数内所有的变量和函数，通过作用域链我们可以查找外部函数的变量和函数，当我们执行函数时会首先查找执行上下文中的变量，若没有则沿着作用域链向上查找，直至全局上下文中查找全局变量。
##### 38.谈谈 This 对象的理解。
this是函数执行上下文中的一个属性，它指向最后一次调用该函数的对象。
函数调用时，若函数不是一个对象的属性，当其调用时this指向全局对象。
方法调用时，若方法为一个对象中的方法，调用该方法时this指向这个对象。
当函数通过构造函数用new来创建时，执行前会创建一个实例对象，这个函数的this指向该实例。
通过运用call、apply、bind方法来改变函数的this指向，call方法第一个参数为改变this指向的对象，后面的参数为传递的参数，apply与call的区别是传递的参数为数组，而bind方法与call和apply的区别是不会立即调用函数，先将函数与this指向绑定，返回改变了this指向的新函数，等到待执行时再调用。这个函数的this指向除了用new构造函数来改变，其余都不会改变。
##### 39.eval 是做什么的？
eval方法是将传递的字符以js语法去解析执行。应该尽量避免使用eval语法，因为是非常消耗性能，第一次解析js语法，第二次执行js语句。
##### 40.什么是 DOM 和 BOM？
  -  DOM是文档对象模型，它是将文档看成一个对象，这个对象主要定义了文档的方法和接口。在DOM中，文档的各个组件可以通过Object.attribute来获取，根对象是document。
  - BOM是浏览器对象模型，它是将浏览器看成是一个对象，这个对象中定义了浏览器的方法和接口。它除了可以访问文档组件以外还可以访问浏览器窗口组件，例如导航条navigator，历史记录history等等。
##### 41.写一个通用的事件侦听器函数。
```js
my.Event = {
  readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        // DOM2
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        // IE 绑定this到element上
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function() {
                handler.call(element);
            });
        // DOM0
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    }, 
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
}
```
##### 42.事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？
事件是用户操作网页过程中的交互动作，例如鼠标点击事件click，鼠标移动事件mousemove等等，除了用户触发外还可以是文档加载，例如页面滚动事件scroll，事件可以封装成一个event对象，包含了事件对象的所有信息和可以对事件的操作。

IE可以支持事件冒泡，火狐可以同时支持两种事件模型，即事件冒泡和事件捕获。

event.stopPropogation或者ie下的event.cancelBubble = true。

##### 43. 三种事件模型是什么？


事件是指用户操作页面过程中触发或者是浏览器触发的交互动作，有三种事件模型。

  - DOM0事件模型，该事件模型没有事件流的概念，这种模型不会传播，它可以直接定义监听函数也可以通过js属性来定义监听函数。

  - IE事件模型，该事件模型涉及两个事件流，执行阶段和冒泡阶段，首先会监听并触发目标事件，然后会依次冒泡到最外层document，所经过的节点依次判断是否绑定了事件，若有则触发。可以通过attachEvent来监听事件，可以监听多个函数并按顺序执行。

  - DOM2事件模型，该事件模型涉及三个事件流，捕获阶段、执行阶段和冒泡阶段，捕获阶段为从document依次向下传播，检查每个节点是否绑定了相关事件，若有则触发。后两者与IE两个阶段相同。可以通过addEventListener来监听事件，第三个参数用来判断捕获和冒泡的顺序。
##### 44.事件委托是什么？
事件委托的本质是通过事件冒泡使父节点能够监听到子节点的事件，从而产生事件函数。也就是将监听函数绑定在子节点的父节点上，这样不必为每个子节点都绑定监听事件，父节点可以通过事件对象定位到子节点目标上。例如当我们动态创建子节点时，动态创建的子节点也可以有监听事件，可以利用事件委托的形式将监听函数绑定在父节点上，可以减少内存上的消耗。
##### 45.["1", "2", "3"].map(parseInt) 答案是多少？
parseInt方法是将数值转为整数型，接收两个参数，分别为val和radix，即数值和基数，基数范围为2~36之间，并且数值不能大于基数值，这样才能正确返回整数型。map方法传递了三个参数，分别为value，index，array，默认第三个参数被省略。这样数组传递给parseInt的参数分别为1-0，2-1，3-2，因为数值不能大于基数，所以后两项返回为NaN，第一项由于基数是0，所以默认为10，返回1。因此答案为[1, NaN, NaN]。
##### 46.什么是闭包，为什么要用它？
闭包是指有权访问另一个函数内变量的函数，例如在函数内创建另一个函数，内部函数能够访问到外部函数局部变量。
闭包用途有二：
  - 函数外部可以访问函数内部的变量，通过闭包函数，我们可以在函数外部调用闭包函数在外部获取到函数内部的变量。
  - 另一个作用是将已经运行结束的函数上下文中的变量对象保存在内存中，通过闭包函数保存了对变量对象的引用，因此这个变量对象不会被回收。
##### 47. javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？
use strict指的是严格模式下执行js语句。主要是消除了一些不规范的语法，提高了解析执行的效率，保证了代码的安全运行。禁止使用with语句，不允许this指向全局对象，对象不能有重名的属性等。
##### 48. 如何判断一个对象是否属于某个类？
  - 通过使用instanceof运算符来判断对象构造函数的原型对象是否出现在原型链上的任何位置。

  - Object.prototype.toString.call来返回[&#91;Class]]属性。
##### 49. instanceof 的作用？
instanceof运算符用于判断构造函数的原型对象是否在实例对象原型链上的某个位置。左对象右构造函数
##### 50.new 操作符具体干了什么呢？如何实现？
```js
function myNew(){
    // 创建一个新对象obj，声明要返回的结果result,取参数的第一项为构造函数fn
    let obj = new Object(),result,fn = [].shift.call(arguments);
    // 将obj.__proto__连接到构造函数fn的原型
    obj.__proto__ = fn.prototype;
    // result接收构造函数执行后的返回结果，this指向obj
    result = arguments.length>0?fn.apply(obj,arguments):fn.apply(obj);
    // fn返回的是一个值的时候，会忽略那个值，返回一个对象时，会返回这个对象
    // 如果构造函数返回一个对象，则将该对象返回，否则返回步骤1创建的对象
    return typeof result === 'object'?result:obj;
  }
```
对于构造函数通过new创建一个新实例对象，在内存上开辟了一个新空间，同时将实例对象的proto属性指向构造函数的prototype原型对象。并且将构造函数的属性通过this指向new创建出的实例对象。判断函数的返回值类型，如果是值类型就返回创建的对象，如果是引用类型就返回引用类型对象。
##### 51.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
hasOwnProperty方法，该方法用于查找对象身上自身特点的属性，而不去查找原型上的属性，会将原型上的属性忽略掉。
##### 52.对于 JSON 的了解？
JSON是一种基于文本的轻量级的数据交换格式，它可以被任何编程语言读取并交换数据格式。

在项目开发中我们常用JSON来进行前后端数据的传递，我们在前端将数据转换为JSON字符串的格式传递给后端，后端接收到数据后通过将其转换为特定的数据结构来进行处理。

因为JSON是基于js语法的，但两者有很大差别，JSON格式更为严格，例如不能使用方法属性，且属性用双引号。

js中提供了两种方法来对JSON格式进行处理，一是JSON.stringify将JSON数据结构转变为JSON字符串的模式。

二是JSON.parse方法将JSON字符串格式转变为js数据结构，若接收到的数据不是JSON字符串格式就会报错，例如我们在后端接收到JSON字符串格式的数据，可以通过JSON.parse将其转变为js数据结构再进行数据处理。
##### 53.能解释一下这段代码的意思吗？
```js
[].forEach.call($$('*'),function(a){
    a.style.outline = "1px solid #"+(~~(Math.random()*(1<<24))).toString(16);
})
```
选中页面所有元素为其添加一个1px随机颜色的边框
  - 选择页面中的所有元素：$$() 函数是现代浏览器提供的一个命令行 API ，它相当于 `document.querySelectorAll()`，可以将当前页面中的 CSS 选择器作为参数传递给此方法，然后它会返回匹配的所有元素。
  - 遍历元素：`[].forEach.call($$('*'),function(a){...})`;  通过使用函数的 call 和 apply 方法进行方法借用，可以实现类似 NodeList 这样的类数组对象上调用数组方法。
  - 为元素添加颜色：a.style.outline="1px solid #"+color ，代码中使用 outline 的 CSS 属性给元素添加一个边框，由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。
  - 生成随机颜色：`(~~(Math.random()*(1<<24))).toString(16) `
  `Math.random()*(1<<24)` 可以得到 0~2^24 -1 之间的随机数，使用了位操作。<< 是左位移操作符

  - 因为得到了一个浮点数，但是我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，使用两个波浪号等价于使用 parseInt：`const a = 12.23;  ~~a === parseInt(a); //true`
  - 然后再用 `toString(16) `方式，转换成一个十六进制的字符串。toString() 方法将数值转换为字符串时，接收一个参数用以指明数值的进制。如果省略了该参数，则默认采用十进制，但可以指定为其他进制。例如十六进制。
##### 54. js 延迟加载的方式有哪些？CSS阻塞？
js代码在解析和执行时会阻塞页面的渲染，阻碍dom向下执行，因此我们希望能够延迟js加载，从而使页面性能更好更加流畅。
  - js阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。
  - 根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。

延迟加载
  - 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。
  - 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。
  - 使用defer（只支持IE）表面页面自上而下执行时若遇到js脚本时不会阻塞页面向下执行，而是加载js脚本和页面解析同时进行，当页面元素全部解析完毕时再按照js脚本的顺序执行js语句。
  - 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用`setTimeout`来调用
  - 可以使用动态创建script标签的方式，我们可以对文档的加载事件进行监听，当页面元素全部加载完毕时再动态创建script标签，进行外部js脚本的外链。
  - 可以通过在script标签添加async属性，它和defer属性的不同是等到js脚本加载完毕就回过头去执行js代码，而不会等到所有页面元素加载完毕，是异步进行的，js脚本不会按照顺序执行，哪个先加载完毕就先执行哪个js代码。
```js
动态加载js
<script>
var script=document.createElement("script");
script.type="text/javascript";
script.src="file.js";
document.getElementsByTagName("head")[0].appendChild(script);
</script>
```

##### 55.Ajax 是什么? 如何创建一个 Ajax？
Ajax属于异步通信，通过XMLHTTPRequest创建xhr，从服务器xml文档中获取数据，并更新到页面局部，不必刷新整个页面。
```js
function ajax(options){
   //设置默认对象 
    var defaults = {
        type: 'get',
        url: '',
        data: {},
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        success: function(){},
        error: function(){}
    };
    //将传入参数对象与默认对象合并
    Object.assign(defaults, options);
    var params = '';
    for(let attr in defaults.data){
        params += attr + '=' + defaults.data[attr] + '&';
    }
    params = params.substr(0, params.length);
    if(defaults.type == 'get'){
        default.url = default.url + '?' + params;
    }
    var xhr = new XMLHTTPRequest();
    xhr.open(defaults.type, defaults.url);
    if(defaults.type == 'post'){
        var contentType = defaults.headers['Content-Type'];
        xhr.setResquestHeader('Content-Type', contentType);
        if(contentType == 'application/json'){
            xhr.send(JSON.stringify(defaults.data));
        } else {
            xhr.send(params);
        }    
    } else {
        xhr.send();
    }
    xhr.onload = function(){
        var contentType = xhr.getResquestHeader('Content-Type');
        var responseText = xhr.responseText;
        if(contentType.includes('application/json')){
            responseText = JSON.parse(responseText);
        }
        if(xhr.status == 200){
            defaults.success(responseText, xhr);
        } else {
            defaults.error(responseText, xhr);
        }
    }
}
```
##### 56. 谈一谈浏览器的缓存机制？
浏览器的缓存机制指的是浏览器能够在一定时间内保存接收到的web资源的副本，当在有效事件内，如果浏览器再次发起相同请求，则直接从缓存中获取数据，不必再向服务器端请求。有效的缓解了服务器端压力以及加快了性能

缓存机制可以分为强缓存和协商缓存。如果为强缓存，在缓存有效时间内，可以直接从缓存中获取资源，不必向服务器端发起请求。强缓存有效时间可以通过设置http头部中的`expries`和`cache-control`来设置。**expries是http1.0中的属性**，它通过设置服务器端绝对时间来控制缓存的有效时间，**但它的缺点是浏览器端和服务器端可能时间不一致，这就导致了缓存有效时间的误差**。可以通过http1.1中的cache-control来控制，它提供了很多不同的控制信息，例如max-age用来指定缓存有效最大时间，这是一个相对时间，相比于第一次浏览器端请求，过了一定时间后缓存失效。还有private用来控制缓存只能被客户端获取，不能被代理服务端获取。还有no-store表示资源不能被缓存，no-cache表示可以被缓存但是会立即失效，每次都要向服务器端发起请求。cache-control的优先级大于expries。

协商缓存策略是浏览器首先向服务器端发送请求，若请求内容和条件自上次请求以来没有发生修改则返回304状态码，如果发生了修改则返回最新修改的资源。协商缓存也可以通过两种方式来设置，第一个是通过设置响应头中的`last-modify`属性，返回了资源最后一次修改时间，当浏览器再次发起请求时请求头中会带有`if-modify-since`属性，属性值即为`last-modify`的值，服务器将获取到的这个头部值与最后一次修改资源的时间进行比较，若发生修改则返回新的资源，若没有修改则告知浏览器使用缓存中的内容。但这个方式有缺陷就是`last-modify`的值只能精确到秒级，如果某些资源在一秒之内修改多次，那么文件发生了修改而`last-modify`没有发生改变。因此第二种方式是通过设置响应头中的`ETag`值，它保存了资源的唯一标识符，当资源发生修改时，`ETag`也会发生改变。当浏览器端向服务器端发起请求时，会在请求头中添加`if-none-match`头部，值为返回的`ETag`值，服务器端会根据这个值与对应文件的ETag值进行对比判断是否发生了修改。当这两个方法同时设置时，`ETag`的优先级会高于`last-modify`。

强缓存和协商缓存都是当缓存命中时直接使用缓存文件，**区别是协商缓存需要先向服务器端发起一次请求**。当强缓存命中时会直接使用缓存资源，若未命中则向服务器端发起请求，**使用协商缓存，若协商缓存命中则告知浏览器使用缓存资源，若未命中则将最新修改过后的资源返回给浏览器端**。

web缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN缓存）、浏览器缓存。
浏览器端缓存包括：HTTP缓存、indexDB、cookie、localstorage
四个术语：缓存命中率、过期内容、验证、失效
浏览器第一次请求（无缓存、向web服务器请求、请求响应、缓存协商【第二次用】）

强缓存：浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
1. 浏览器先根据这个资源http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。强
2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。协商
3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。

命中强缓存，浏览器并不会将请求发送给服务器，http200，size会显示from cache。利用返回头中expires和cache-control，expire绝对时间，客户端和服务端时间不一致就会造成误差。

协商缓存：若未命中强缓存，则浏览器会将请求发送至服务器，服务器根据http头信息中的`if-modify-since`（精度问题）和`ETag`来判断是否命中协商缓存，如果命中，则返回304，浏览器从缓存中加载资源。

强缓存优势：提高并发效率,很多资源不需要重复请求直接从浏览器中拿缓存。


##### HTTP请求
当我们在web浏览器中输入一个网址发生了什么？
  1. 对这个网址进行DNS域名解析，得到对应的ip地址
  2. 根据这个ip地址，找到服务器，发起TCP的三次握手
  3. 建立TCP连接后发起HTTP请求
  4. 服务器响应HTTP请求，浏览器得到HTML代码
  5. 浏览器解析HTML代码，并请求代码中资源（js、css、图片，先得到html代码后才能去找这些资源）
  6. 浏览器对页面进行渲染呈现给用户
  7. 服务器关闭TCP连接
注：tcp是比http更底层的一个连接协议，http是应用层的，tcp是传输层
DNS怎么找到域名的，采取递归查询的方式，浏览器缓存-系统缓存-host，缓存找不到就递归找根域名服务器，根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器。
- 为什么HTTP协议要基于TCP来实现？
TCP是一个端到端的可靠的面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当错误发生时，会重传，TCP有状态，HTTP无状态）
- 最后一步浏览器是如何对页面进行渲染的？
解析html文件构成DOM树，解析CSS文件构成CSSOM树，执行js，根据dom树和cssom树生成渲染树，渲染树是按顺序展示在屏幕上的一系列矩形，这些矩形带有字体颜色和尺寸视觉属性，根据渲染树节点树每一个节点布局在屏幕上正确位置，遍历渲染树绘制所有节点，为每一个节点适用对应的样式，通过UI后端模块完成
- 一般情况下，一旦web服务器向浏览器发送了请求数据，它就要关闭tcp连接，然后如果浏览器或者服务器在头信息加入了Connection：keep-alive TCP连接在发送后仍然保持打开状态，羽是浏览器可以继续通过相同的连接发送请求，保持连接节省了为每个请求建立新连接所需的事件，节约了网络带宽。
- 三次握手本质就是确认通信双方收发数据的能力
- HTTP1.0 短连接，拿到html就断开，分析html后再去依次建立tcp去拿css js 图片等信息
- HTTP1.1 默认长连接（keep-alive）
- SSL（安全套接层）标准化之后改名TLS（传输层安全协议）HTTPS是HTTP over SSL，应用层下面加了一个安全层。
- CA证书，增加窃听成本，还是解决不了窃听问题，只是相对安全
- [HTTPS、TLS](https://blog.csdn.net/freekiteyu/article/details/76423436)
- [TCP、HTTP各种状态码](https://blog.csdn.net/ThinkWon/article/details/104903925)

##### 57. Ajax 解决浏览器缓存问题？
  1. 在ajax发送请求前加上 `anyAjaxObj.setRequestHeader("If-Modified-Since","0")`。
  2. 在ajax发送请求前加上`anyAjaxObj.setRequestHeader("Cache-Control","no-cache")`。
  3. 在URL后面加上一个随机数：`"fresh=" + Math.random()`;。
  4. 在URL后面加上时间搓：`"nowtime=" + new Date().getTime()`;。
  5. 如果是使用jQuery，直接这样就可以了`$.ajaxSetup({cache:false})`。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。

##### 58.同步和异步的区别？
同步指的是代码自上而下按顺序执行，并且等待当前代码返回值或消息之后再继续执行下一条语句，此时程序是处于阻塞状态的，只有当前代码返回值后才能继续向下执行。

异步指的是代码不会按照同步的方式等待当前向系统请求后返回消息之后再向下执行，它会在代码请求的时候直接执行之后的语句，不会等待消息的返回，不会造成程序阻塞。等到消息返回后再处理之前异步的程序。
##### 59.什么是浏览器的同源政策？
同源政策指的是协议、域名以及端口号任意一个不相同则为非同源，非同源之间不能通过js获取到其他网站的cookies、localstorage等，以及不能通过js操作其他网站的DOM，并且不能通过ajax进行跨域请求。

同源政策保证了用户信息的安全，但它不限制浏览器，对于img，script等html元素不会进行同源政策限制。因为这些操作不会通过响应结果而带来安全性的问题。

##### 60.如何解决跨域问题？
  1. jsonp:利用 \<script\> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定 需要对方的服务器做支持才可以。JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅**支持get方法**具有局限性, 不安全可能会遭受XSS攻击。
  2. cors:CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
  3. postMessage:postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
页面和其打开的新窗口的数据传递
多窗口之间消息传递
页面与嵌套的iframe消息传递
上面三个场景的跨域数据传递
postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。
4. websocket:Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
原生WebSocket API使用起来不太方便，我们使用socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容
5. Node中间件代理(两次跨域):实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：
接受客户端请求 。
将请求 转发给服务器。
拿到服务器 响应 数据。
将 响应 转发给客户端。
6. nginx反向代理:实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求.
使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
7. window.name + iframe:window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
8. location.hash + iframe
实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000
9. document.domain + iframe
该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加 `document.domain='test.com'`表示二级域名都相同就可以实现跨域。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
##### 61. 服务器代理转发时，该如何处理 cookie？
roxy_cookie_path 的作用是用来改变cookie的路径
语法：` proxy_cookie_path` `path` `replacement`; path就是你要替换的路径 replacement 就是要替换的值
host、端口转换，cookie不会丢失;路径也变化，则需要设置cookie的路径转换;直接代理本地端口
##### 62.简单谈一下 cookie ？
我理解的是cookie是服务器端创建的用于维护会话状态信息的数据，当客户端向服务器发起请求时，服务器端创建cookie并且将sessionid储存于cookies中发送给客户端，等到之后每次客户端向服务器端发起请求时，都会携带cookies用于服务器进行验证，用户是否为登录状态。cookies不能用于跨域请求。
服务器端可以使用set-cookies来设置cookies信息，其中expries用于设置cookies过期时间，httponly用于禁止js脚本获取到cookies，只能被服务器访问。除此之外还有domain、path、secure。
##### 63.模块化开发怎么做？
对于模块化开发的理解是，不同模块实现了不同功能的一组方法，随着程序越来越复杂，模块化开发越来越重要。
##### 64.js 的几种模块规范？
commonJS：主要应用于服务器端，通过module.exports将模块进行导出，暴露出模块接口，通过require引入模块，实现模块的导入。commonJS是同步执行的，因为涉及到的文件方法缓存在本地磁盘中因此读取时不会发生阻碍，同步执行不会产生代码的拥堵现象。
ES6模块规范：使用import和export方式来输出和导入模块。
AMD：RequireJS实现的异步加载模块。

##### 70. documen.write 和 innerHTML 的区别？
document.write是改写页面结构，会代替整个文档重写整个页面。

innerHTML只是替代页面某个元素中的内容，只会重写部分元素的内容。
##### 71.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？
创建新节点：createElement()、createTextNode()

添加、移除、替换、插入节点：Parent.appendChild(node)、Parent.removeChild(node)、Parent.replaceChild(new, old)、Parent.insertBefore(new, old)

查找节点：getElementById, getElementsByName, getElementsByTagName, getElementsByClassName, querySelector, querySelectorAll

属性操作：getAttribute, setAttribute, hasAttribute, removeAttribute

##### 72.innerHTML 与 outerHTML 的区别？
带标签和不带标签

##### 73.call() 和 .apply() 的区别？
两者作用相同，只是传入的参数形式不一样，call第一个参数为this指向对象，第二个参数之后为依次向函数内部传入的参数。apply第一个参数为this指向的对象，第二个参数为向函数传入的参数数组。

###### 74.JavaScript 类数组对象的定义？
类数组指的是拥有数组的length属性和索引下标，类数组与数组类似，但不能使用数组的方法。

可以通过以下几种方式来使类数组拥有数组的方法：

通过call调用数组的slice方法来实现转换：

Array.prototype.slice.call(arrayLike);
通过call调用数组的splice方法来实现转换：

Array.prototype.splice.call(arrayLike, 0);
通过apply调用函数的concat方法来实现转换：

Array.prototype.concat.apply([], arrayLike);
通过Array.from来实现转换：

Array.from(arrayLike);

##### 75.数组和对象有哪些原生方法，列举一下？
数组和字符串的转换方法：toString()、join()

数组尾部操作方法：push()，pop()，push参数可以为多个

数组头部操作方法：shift()，unshift()

数组重排序的方法: reverser() sort()

数组连接的方法：concat() 返回的是拼接好的数组，不影响原数组

数组截取方法：slice(start, end) 用于截取数组中的一部分进行返回 不影响原数组

数组删除方法：splice(start, number) 用于删除数组中的指定项 返回被删除的数组，影响原数组

every() some() forEach() filter() map()

reduce()

##### 76.数组的 fill 方法？
数组的fill方法可以用一个固定值填充数组从起始索引到终止索引的全部元素。fill接收三个参数，固定值，起始索引，终止索引。其中起始索引和终止索引可省略，默认为0和this对象的length值。

##### 78. JavaScript 中的作用域与变量声明提升？


变量声明提升是指对变量的声明仿佛提升到了当前作用域的顶部。这是js中的作用域相关，当代码在执行前会有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象，当访问到一个变量时会到当前作用域的执行上下文中去查找变量对象，作用域的首部就是当前执行上下文中的变量对象，包括函数的形参、所有函数和声明的变量。
##### 79.如何编写高性能的 Javascript ？
避免使用过深的嵌套，避免使用未声明的变量，当需要多次访问数组的长度时，可以将长度储存起来。
##### 80. 简单介绍一下 V8 引擎的垃圾回收机制
标记清除：定期对带有标记的变量进行清除，首先会将全局中所有变量进行标记，然后将被一些对象引用或者即将被引用的变量清除标记，剩下的就是等到垃圾回收机制销毁的变量。

引用计数：判断一个变量是否有对象引用它，如果没有对象引用就清除这个变量。
##### 81.哪些操作会造成内存泄漏？
内存泄漏指的是，系统中的内存空间不断的缩小，这是因为不断的有变量占用内存空间得不到释放。

未声明的局部变量，会产生全局变量，使这个变量一直存在于内存中无法被回收。

闭包：当不合理的使用闭包时，会造成一些变量一直留在函数中无法得到释放。

我们获取到一个DOM元素的引用，而当这个元素被删除使，一直保留着这个元素的引用，因此一直占用内存空间得不到释放。

我们若设置了定时器而没有清除它，如果定时器的循环函数一直有对外部变量的引用的话，那么这个变量会一直保存在内存中得不到释放。
###### 82.需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？
###### 85.移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？
移动端的点击事件有300ms的延迟，这是因为移动端有双击放大功能，有300ms的延迟是为了等待是否有第二次点击来进行屏幕放大，若300ms内没有第二次点击再认为是点击事件。解决：可以再view标签内设置禁止缩放属性，也可以设置屏幕为理想尺寸大小，同时还可以使用fastClick库。

点击穿透：是因为移动端的点击事件有300ms的延迟，touch之后300ms内响应click，这样可能会误点到元素底部的某个元素。解决方案：只用touch，若只用click的话每次点击都会有延迟现象。
##### 86.什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？
前端路由指的是不同路由对应的不同功能的页面交给前端来做，之前是服务器通过url的不同来返回不同的页面。

一般单页面应用时候适合前端路由，大部分页面结构不改变，只改变部分结构。

前端路由优点：不必向服务器端请求，缓解了服务器端压力，用户体验好，页面流畅。

前端路由缺点：单页面应用无法记住之前滚动过得位置，也无法在前进后退过程中记住滚动的位置。

前端路由有两种实现方式，一种是hash，另一种是history.pushState。pushState为浏览器添加一条历史记录，添加完后可以使用history.state获取。并且在history模式下，前端的url必须与向后端传递的url保持一致。
#####  87.Object.is() 与原来的比较操作符 “===\”、“\==” 的区别？
==表示在比较前可以进行类型转换，===表示严格比较，若类型不同会直接返回false

Object.is()与===类似，但处理了一些特殊情况，比如+0和-0不再相对，NaN和自身是相等的。
##### 88.escape,encodeURI,encodeURIComponent 有什么区别？
##### 99.为什么 0.1 + 0.2 != 0.3？如何解决这个问题？
在计算机中，运算是转换为二进制再进行计算的，js是以64位双精度格式来进行计算的，只有53位有效数字，之后的数字会被截掉，因此产生了误差。
由于小数的运算可能导致精度丢失问题，那么要解决这个问题，可以将其转换为整数后再进行运算，运算后再转换为对应的小数
当然，除了上述方式外，我们也可以利用 ES6 中的极小数 Number.EPSILON 来进行判断。
例如判断 0.1 + 0.2 是否等于 0.3，可以将两个数字相加的结果与 0.3 相减，如果想着的结果小于极小数，那么就可以认定是相等的：​​​​​​​

