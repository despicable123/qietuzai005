## 防抖节流
- 本质上是优化高频率执行代码的一种手段
- 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
- 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率
- 定义：节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次执行    场景：resize、scroll、mousemove
        防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时  场景：实时搜索联想
# 节流
```js
// 用来返回节流函数的工具函数
function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        //不传递this的话会丢失this指向
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn.apply(context, args), remaining);
        }
    }
}
```

# 防抖
```js
function debounce(calllback, delay) {
  return function() {
    //启动定时器，只是准备真正处理
    if(callback.hasOwnProperty('timeoutId'){
      clearTimeout(callback.timeoutId)
    })
    callback.timeoutId = setTimeout(()=>{
      callback.apply(this,arguments)
      //标记事件已经正在处理
      delete callback.timeoutId // 或者 clearTimeout(callback.timeoutId)
    },delay)
  }
}
```

## webpack
- 一切文件皆为模块，都有依赖关系
- 从入口文件开始，递归找到所有文件依赖模块，内部构建一个依赖图，依赖图会映射项目所需的每个模块，并生成一个或多个bundle文件
- webpack与webpack-cli在4.0之后的区别（webpack做js的打包工作，-cli解析webpack命令，命令内部使用webpack功能）
- webpack不用全局下载，只需要局部下载即可：原因公司多个项目可能使用不同版本的webpack
- 使用npx webpack使用局部webpack进行打包，
- 使用npm script运行的webpack命令默认先找的是局部的webpack
- webpack本身能解析打包各种模块规范的js代码（ES6、CommonJS、AMD、CMD）
- 核心概念（模式、入口、输出、加载器、插件）
### 处理
1. loader处理
2. plugin处理
3. devtool
4. devSever
### 搭建环境
1. 基础环境
2. vue环境
3. react环境

## XSS（跨站脚本攻击）
1. 通过html注入篡改了网页，插入了恶意的脚本，反射型xss、存储型xss、dom based xss
2. XSS payload，xss攻击成功后往页面植入恶意脚本，这些脚本被称为xss payload，常见的是通过读取浏览器的cookie对象，发起cookie劫持，构造get post请求、构造技巧，利用字符编码，window.name可以跨域，为了绕过长度限制，藏代码最好地方是location.hash，用eval执行
3. 防御xss：httpOnly，服务器返回时发送Set-Cookie头，向客户端写入Cookie，httpOnly在此时标记，不允许客户端脚本访问。输入输出检查。

## CSRF （跨站点请求伪造）
1. 诱使用户访问一个页面，以该用户身份在第三方站点里执行一次操作，伪造请求这种攻击就叫做跨站点请求伪造。
2. 浏览器Cookie策略，两种Cookie：Session Cookie（临时Cookie，保存浏览器进程的内存空间）和Third-party Cookie（本地Cookie，保存在本地）
3. 本地Cookie设置了过期时间，到期才失效，临时Cookie关浏览器就没了，ie禁止浏览器在img、iframe、script、link标签中发送本地Cookie，但是p3p头允许跨域设置Cookie，p3p策略是一一对应的
4. CSRF的防御：
   - 验证码：CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码强制用户和应用进行交互，才能完成最终请求。但是不能给所有请求都加验证码，是一种辅助手段。
   - Refer Check：最常见的应用是防止图片盗链，用于检查请求是否来自合法的源，比如论坛发帖操作，提交发帖表单时，Refer值必然时发帖表单所在的页面，如果refer值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。缺陷在于，服务器并非上面时候都能取到referer，很多用户处于隐私保护的考虑，限制了refer的发送，在某些情况下，比如HTTPS跳转HTTP，出于安全考虑，浏览器不会发送Refer。
   - token：要真随机数，尽量存在服务器端的session中，防止出现在referer中，用POST请求，此方案仅用于对抗CSRF，如果网站还存在XSS漏洞token会被访问到然后再构造除一个合法的请求，这个过程可以称为XSRF。

## Oath
1. A网站想获取用户在B平台的信息，引导用户访问B平台的授权页面。
2. 用户同意授权后重定向至A网站，A后台获取一个code，拿code去B平台换取access_token和用户id，access_ token和用户id去换取用户信息。


## cookie、session、jwt、token
1. http是无状态的，上面的方式其实都是为了让客户端-服务端进行有状态的对话。
2. cookie+session坏处是session存在内存中，服务端重启后所有用户都需要重新登录。浏览器禁用cookie之后回造成用户会话永久失效，因为发起请求中没有cookie，服务端无法识别用户，用nignx做负载均衡集群的时候，登录session存在a服务器，请求发到b服务器去的时候就无法验证，需要用户重新登录，虽然可以用ip hash解决这个问题，但是负载均衡就失去意义了。好处是浏览器都内置了对cookie seesion的处理，不需要后端及前端开发人员理解交互逻辑，一个api即可完成认证，服务端可以控制cookie+session机制的有效会话事件
3. cookie+session更适合于单体web服务，在前后端不分离的项目用的比较多。
4. jwt
   - 优点是无状态去中心化的，支持移动设备，支持跨程序调用，cookie是不允许跨域访问的，加密特性保证了token不可伪造和篡改。
   - 缺点是jwt仅在生成时支持失效时间，失效时间固定，不可主动失效，不可存储大量信息。

##### 1.js基本数据类型
js的基本数据类型有字符型、数值型、布尔值、null、undefined和es6新增的symbol。symbol主要作用是给变量提供唯一的标识，可以解决全局变量冲突的问题。
##### 2.JavaScript 有几种类型的值？你能画一下他们的内存图吗？
栈：基本数据类型

堆：引用数据类型

两者区别在三个方面：

声明变量时不同内存位置不同：基本数据类型变量的值储存在栈中，这是因为基本数据类型占据的空间内存是固定的，因此可以直接访问。引用数据类型储存在栈中的是变量的地址指针，指向堆中的引用。因为引用数据类型的大小会改变因此不能储存在栈中会影响查找的速率。

访问机制不同：在JavaScript中是不允许直接访问储存在堆内存中的变量的，能够访问的是堆内存中的地址，然后按照地址去访问引用类型，而栈中的数据变量是可以直接访问到的。

复制变量时不同：栈中的变量复制时会将数值保存为另一个副本，这两者是相互独立的。而堆中的对象进行复制时是将保存着内存地址的变量赋值给另一个变量，两者引用地址相同，它们中任何一个进行修改时都会改变另一个变量。

传递参数时不同：传递参数是将变量的值传递给形参，引用数据类型中的值为该变量在堆内存中的地址，因此将引用数据类型作为参数传递时在函数内部对变量进行修改会影响函数外部该引用数据的值。
##### 3.什么是堆？什么是栈？它们之间有什么区别和联系？
栈和堆的概念来自于从数据结构和操作系统中。

数据结构中栈为先进后出队列，而堆为优先级队列，二叉树为典型的堆队列。

操作系统中栈区内存由编译器自动释放，主要储存函数的参数、局部变量等，结束后自动销毁。堆区内存主要靠程序员手动释放，若没有手动释放，垃圾回收机制会将其回收。
##### 4.内部属性 [&#91;Class]] 是什么？
所有用typeof返回为object的变量都含有一个内部属性[&#91;Class]]，可以看成是内部的分类，利用Object.prototype.toString.call()可返回该分类。

例如Object.prototype.toString.call([]) 返回[&#91;Object Array]]
##### 5.介绍 js 有哪些内置对象？
js中的内置对象指的是在操作前由js定义的存在于全局作用域中的全局值属性、函数对象、以及可实例化的构造函数。全局值属性例如NaN、null等，函数有parseInt、parseFloat等，可实例化其他对象的构造函数Number、Boolean、Function等以及还有Date、数学对象Math等。
##### 6.undefined 与 undeclared 的区别？
已在全局中声明但还没有赋值的变量返回undefined，未声明的变量是undeclared。会报错返回is not defined。
#####  7.null 和 undefined 的区别？
null表示这个值被定义了但是这个值是空值，是对象原型链的终点，undefined表示缺值。Number(null)输出为0, Number(undefined)输出为NaN

首先null和undefined都是基本数据类型。

undefined表示变量未定义，null代表的含义是空对象，一般变量未定义的时候会返回undefined，null一般作为变量对象的初始值。

typeof null 会返回object。null == undefined 返回true，但三个等号返回false。
##### 8.如何获取安全的 undefined 值？
表达式void _ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。
按惯例我们用void 0来获得 undefined。
##### 9.说几条写 JavaScript 的基本规范？
在日常书写JavaScript代码时应该遵循一些基本规范利于读者阅读以及日后维护。例如：

变量声明尽量放在作用域的前面，并且var声明时最好给予初始值。

用===和!&#61;=来代替&#61;=和！=。

不要给内置对象的原型对象上添加方法，例如Array，Object，Function等。

代码中出现地址、时间等常量用变量来代替。

switch语句必须带有default分支。

if和for语句要有大括号。
##### 10.JavaScript 原型，原型链？ 有什么特点？
在JavaScript中我们使用构造函数创建一个实例对象时，每个构造函数内部都有一个prototype属性，这个属性是一个对象，即原型对象。实例对象内部的 proto 属性指向构造函数的原型对象，并且该原型对象也可看成其他构造函数的实例，这个proto属性链就是原型链。当我们要查找实例对象身上的某个属性及方法时，若该实例对象身上没有，可沿着proto属性一级一级向上找，直至Object.prototype。

特点：JavaScript中是利用引用来进行传递的，当我们修改了某一原型的属性时，所有继承都会被修改。
##### 11.js 获取原型的方法？
- P.constructor.prototype
- Object.getPrototypeOf(P)
- P.proto
##### 12.在 js 中不同进制数字的表示方式
- 以 0X、0x 开头的表示为十六进制。
- 以 0、0O、0o 开头的表示为八进制。
- 以 0B、0b 开头的表示为二进制格式。
#####  13.js 中整数的安全范围是多少？
JS 中所有的数字类型，实际存储都是通过 8 字节 double 浮点型 表示的。安全整数指的是该整数转换为二进制时精度不会丢失。最大值指的是2的53次幂-1，超过安全整数范围在计算时会有误差。在ES6中被定义为Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER。当超过整数范围时会返回infinity。
##### 14.typeof NaN 的结果是什么？
typeof NaN会返回number。NaN是一个特殊值，它与自身不相等，NaN !=NaN 为true
#####  15.isNaN 和 Number.isNaN 函数的区别？
isNaN接收参数时会尝试将其转化为数值型再判断，因此传入的不能转换为数值的会返回true，但非数值型也会返回true，影响了NaN的判断。

Number.isNaN会先判断其是否为Number，然后在进行isNaN判断。判断更为准确。
##### 16.Array 构造函数只有一个参数值时的表现？
Array构造函数只有一个参数值时会让其视为创建数组的长度length值，而非充当一个元素。但创建出来的数组依然是个空数组，但有预设长度值。
##### 17.其他值到数字值的转换规则？
undefined返回NaN。
null返回0.
true返回1，false返回0.
字符串类型的值转换为数值型如同利用Number()，若字符串中含有非数字型返回NaN，空字符串返回0.
##### 18.其他值到布尔类型的值的转换规则？
转换为false的有六种：
null、undefined、false、""、NaN、+0、-0
#####  19.{} 和 [] 的 valueOf 和 toString 的结果是什么？
{}的valueOf为{}，toString为[Object Object]
[] 的valueOf为 [], toString为“”
##### 20.什么是假值对象？
在某些情况下，浏览器在一些常规的JavaScript基础上自行创建的一些对象，这些对象强制转换为布尔值时为false，例如document.all为一个伪数组，表示页面中所有元素的数组，由DOM提供给JavaScript使用。
##### 21.~ 操作符的作用？
~表示按位取反，~~可以用于取整。
##### 22.解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？
解析字符串中的数字允许含有非数字，例如parseInt解析字符串时会返回开头的数值，若第一个字符为非数字，则返回NaN，而Number（）解析字符串时字符中不能含有不合法字符。否则返回NaN.
##### 23.其他值到字符串的转换规则？
toString（）
##### 24.+ 操作符什么时候用于字符串的拼接？
当+操作符前后两个变量至少一个为字符串时，两者用+连接为字符串拼接。若两者都为数字，则会数字加法运算。而除了+以外的其他运算符，只要其中一方为数字，另一方就会转换为数字。
##### 25. 什么情况下会发生布尔值的隐式强制类型转换？
例如在if语句中进行判断时会转换为布尔值，还有while语句。三项表达式。for（ ； ； ）中的第二项。逻辑运算符||和&&进行判断时。
##### 26. || 和 && 操作符的返回值？
首先会对第一项进行布尔值强制类型转换。

运用||运算符时，当第一项为true，则直接返回true，当第一项为false，则返回第二项的布尔值

运动&&运算符时，当第一项为true，则返回第二项的布尔值，当第一项为false，则直接返回false。
##### 27.Symbol 值的强制类型转换？
symbol值可以进行显性类型转换 但不能进行隐形类型转换 会报错。
symbol值不能转换为数值型，但可以转化为布尔值，不管是显性还是隐性都是true。
##### 28. == 操作符的强制类型转换规则？
- 字符串和数值型进行==比较时，将字符串转换为数值型再进行比较。
- 其他类型跟布尔值进行比较时，先将布尔值转换为数值型，再进行其他比较。
- NaN和本身取==时为false
- null == undefined 为true
- 如果两个操作值都是对象，则需比较两者是否为同一个引用对象。
##### 29. 如何将字符串转化为数字，例如 '12.3b'?
- 使用Number（）方法，但前提是所包含的字符串不包含不合法字符。
- parseInt（）方法，取整。
- parseFloat（）方法，浮点数
- 隐式类型转换
##### 30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?
使用正则表达式方法
```js
function format(number)
{  return number && number.replace(/(\d)(?=(\d{3}+\.))/g, function($1, $2, $3){  return $2 + ',';  }) }
```
?=pattern 表示匹配到pattern的开始位置的字符，例如window(?=95|98|2000|xp)，可以匹配到window2000中的window。
##### 31. 常用正则表达式
##### 32.生成随机数的各种方法？
Math.random() 生成[0, 1) 范围内的随机浮点数。
##### 33. 如何实现数组的随机排序？
1. 随机抽取下标
```js
  function randomsort(arr){  
    var newarr = [];  
    while(arr.length > 0){   
      var index = Math.floor(Math.random()*arr.length);   
      newarr.push(arr[index]);   
      arr.splice(index, 1);  
    }
    return newarr; 
  }
```
2. 洗牌法
```js
  function randomsort(arr){  
    let leng = arr.length,  
    tempindex;  
    for(var i = 0; i < leng; i++){  
      tempindex = Math.floor(Math.random()*(leng - i) + i);  
      [arr[i],arr[tempindex]] = [arr[tempindex],arr[i]] 
    }  
    return arr; 
  }
```
##### 34. javascript 创建对象的几种方式？
1. 字面量
2. 工厂模式
```js
// 工厂函数
function createPerson ( name, age ) {
    var object = new Object();
    object.name = name;
    object.age = age;
    object.getName = function(){
        return object.name;
    }
    return object;
}
```
3. 构造函数模式
```js
function Person( name, age ) {
    this.name = name;
    this.age = age;
    this.getName = function(){ 
        return this.name;
    };
}
```
4. 原型模式
```js
function Dog(){}
  Dog.prototype.name="旺财";
  Dog.prototype.eat=function(){
  alert(this.name+"是个吃货");
  }
  var wangcai =new Dog();
  wangcai.eat();
```
5. 混合模式
```js
function Car(name,price){
  this.name=name;
  this.price=price; 
  }
  Car.prototype.sell=function(){
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
  var camry =new Car("凯美瑞",27);
  camry.sell();
```
##### 35.JavaScript 继承的几种实现方式？
1. 原型链继承
- 将子构造函数的原型对象指向父构造函数的实例对象，那么子构造函数的实例对象可继承父类上的属性及方法。缺点是创建子类时不能向父类传参，并且父类原型上的所有引用类型可应用到所有实例对象上。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
  } 
  Father.prototype.getName = function(){  
    return this.name; 
  } 
  function Child(skill){  
    this.skill = skill; 
  } 
  Child.prototype = new Father('zhangsan', 20); 
  var child = new Child('dance'); 
  console.log(child.getName());
```

2. 盗用构造函数继承
- 通过在子类中使用对父构造函数使用call方法来调用，并且修改this指针指向子类，同时可以传递参数。优点：避免了引用类型的属性被所有实例共享，也解决了不能传参的问题。缺点是因为方法都在构造函数中定义了，因此每次创建实例时都要创建一遍方法。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age;  
  this.getName = function(){   return this.name;  }  
  this.getAge = function(){   return this.age;  } 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.getName())
```

3. 组合继承
- 结合原型链继承和盗用构造函数继承，二者优点集中起来
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
} 
Father.prototype.money = function(){  
  console.log('100000'); 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill; 
} 
Child.prototype = new Father(); 
Child.prototype.constructor = Child; 
Child.prototype.exam = function(){  
  console.log('i want to have an exam');
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.money())
```
4. 原型式继承
- 原则上只是进行了一次浅复制，适合不需要单独创建构造函数的场合，但仍然需要在对象间共享信息，包含的引用值时终会在相关对象间共享，跟使用原型模式是一样的。es5增加了Object.creat()方法等同于下面函数。
```js
function creatObj(o){  
  function F(){};  
  F.prototype = o;  
  return new F(); 
} 
  var person = {  name: 'zhangsan',  age: 20 } 
  var person1 = creatObj(person); 
  var person2 = creatObj(person); 
  person1.name = 'lisi'; 
  console.log(person1.name, person2.name);
```
5. 寄生式继承
- 类似原型式继承，创建了一个封装继承过程的函数，该函数在内部以某种方式来增强对象，在考虑对象不是自定义类型和构造函数的情况下，寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。
```js
function object(o){
    function F() {}
    F.prototype = o;
    return new F();
}
function createAnother(original){
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式来增强这个对象
        console.log("Hi");
    };
    return clone; //返回这个对象
}
var person = {
    name:"李白",
    friends:["杜甫","陆游"]
};
var anotherPerson = createAnother(person)
anotherPerson.sayHi();//Hi
```
6. 寄生式组合继承
- 寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。“寄生组合继承”用了“寄生继承”修复了“组合继承”的小bug，让js完美实现继承了。
```js
// 实现继承的简单方法
function object(o){
function F () {};
F.prototype = o;
return new F();
}
// 寄生继承
function inheritPrototype(subType, superType){
  var prototype = object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}
function testObject() {
var A = function(){}, 
B = function(){}, a, b;
inheritPrototype(B, A)
}
```

##### 37.Javascript 的作用域链？
作用域链是保证执行函数时变量对象的有序访问，是指向变量对象的有序列表，变量对象包含执行函数内所有的变量和函数，通过作用域链我们可以查找外部函数的变量和函数，当我们执行函数时会首先查找执行上下文中的变量，若没有则沿着作用域链向上查找，直至全局上下文中查找全局变量。
##### 38.谈谈 This 对象的理解。
this是函数执行上下文中的一个属性，它指向最后一次调用该函数的对象。
函数调用时，若函数不是一个对象的属性，当其调用时this指向全局对象。
方法调用时，若方法为一个对象中的方法，调用该方法时this指向这个对象。
当函数通过构造函数用new来创建时，执行前会创建一个实例对象，这个函数的this指向该实例。
通过运用call、apply、bind方法来改变函数的this指向，call方法第一个参数为改变this指向的对象，后面的参数为传递的参数，apply与call的区别是传递的参数为数组，而bind方法与call和apply的区别是不会立即调用函数，先将函数与this指向绑定，返回改变了this指向的新函数，等到待执行时再调用。这个函数的this指向除了用new构造函数来改变，其余都不会改变。
##### 39.eval 是做什么的？
eval方法是将传递的字符以js语法去解析执行。应该尽量避免使用eval语法，因为是非常消耗性能，第一次解析js语法，第二次执行js语句。
##### 40.什么是 DOM 和 BOM？
  -  DOM是文档对象模型，它是将文档看成一个对象，这个对象主要定义了文档的方法和接口。在DOM中，文档的各个组件可以通过Object.attribute来获取，根对象是document。
  - BOM是浏览器对象模型，它是将浏览器看成是一个对象，这个对象中定义了浏览器的方法和接口。它除了可以访问文档组件以外还可以访问浏览器窗口组件，例如导航条navigator，历史记录history等等。
##### 41.写一个通用的事件侦听器函数。
```js
my.Event = {
  readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        // DOM2
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        // IE 绑定this到element上
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function() {
                handler.call(element);
            });
        // DOM0
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    }, 
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
}
```
##### 42.事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？
事件是用户操作网页过程中的交互动作，例如鼠标点击事件click，鼠标移动事件mousemove等等，除了用户触发外还可以是文档加载，例如页面滚动事件scroll，事件可以封装成一个event对象，包含了事件对象的所有信息和可以对事件的操作。

IE可以支持事件冒泡，火狐可以同时支持两种事件模型，即事件冒泡和事件捕获。

event.stopPropogation或者ie下的event.cancelBubble = true。

##### 43. 三种事件模型是什么？


事件是指用户操作页面过程中触发或者是浏览器触发的交互动作，有三种事件模型。

  - DOM0事件模型，该事件模型没有事件流的概念，这种模型不会传播，它可以直接定义监听函数也可以通过js属性来定义监听函数。

  - IE事件模型，该事件模型涉及两个事件流，执行阶段和冒泡阶段，首先会监听并触发目标事件，然后会依次冒泡到最外层document，所经过的节点依次判断是否绑定了事件，若有则触发。可以通过attachEvent来监听事件，可以监听多个函数并按顺序执行。

  - DOM2事件模型，该事件模型涉及三个事件流，捕获阶段、执行阶段和冒泡阶段，捕获阶段为从document依次向下传播，检查每个节点是否绑定了相关事件，若有则触发。后两者与IE两个阶段相同。可以通过addEventListener来监听事件，第三个参数用来判断捕获和冒泡的顺序。
##### 44.事件委托是什么？
事件委托的本质是通过事件冒泡使父节点能够监听到子节点的事件，从而产生事件函数。也就是将监听函数绑定在子节点的父节点上，这样不必为每个子节点都绑定监听事件，父节点可以通过事件对象定位到子节点目标上。例如当我们动态创建子节点时，动态创建的子节点也可以有监听事件，可以利用事件委托的形式将监听函数绑定在父节点上，可以减少内存上的消耗。
##### 45.["1", "2", "3"].map(parseInt) 答案是多少？
parseInt方法是将数值转为整数型，接收两个参数，分别为val和radix，即数值和基数，基数范围为2~36之间，并且数值不能大于基数值，这样才能正确返回整数型。map方法传递了三个参数，分别为value，index，array，默认第三个参数被省略。这样数组传递给parseInt的参数分别为1-0，2-1，3-2，因为数值不能大于基数，所以后两项返回为NaN，第一项由于基数是0，所以默认为10，返回1。因此答案为[1, NaN, NaN]。
##### 46.什么是闭包，为什么要用它？
闭包是指有权访问另一个函数内变量的函数，例如在函数内创建另一个函数，内部函数能够访问到外部函数局部变量。
闭包用途有二：
  - 函数外部可以访问函数内部的变量，通过闭包函数，我们可以在函数外部调用闭包函数在外部获取到函数内部的变量。
  - 另一个作用是将已经运行结束的函数上下文中的变量对象保存在内存中，通过闭包函数保存了对变量对象的引用，因此这个变量对象不会被回收。
##### 47. javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？
use strict指的是严格模式下执行js语句。主要是消除了一些不规范的语法，提高了解析执行的效率，保证了代码的安全运行。禁止使用with语句，不允许this指向全局对象，对象不能有重名的属性等。
##### 48. 如何判断一个对象是否属于某个类？
  - 通过使用instanceof运算符来判断对象构造函数的原型对象是否出现在原型链上的任何位置。

  - Object.prototype.toString.call来返回[&#91;Class]]属性。
##### 49. instanceof 的作用？
instanceof运算符用于判断构造函数的原型对象是否在实例对象原型链上的某个位置。左对象右构造函数
##### 50.new 操作符具体干了什么呢？如何实现？
```js
function myNew(){
    // 创建一个新对象obj，声明要返回的结果result,取参数的第一项为构造函数fn
    let obj = new Object(),result,fn = [].shift.call(arguments);
    // 将obj.__proto__连接到构造函数fn的原型
    obj.__proto__ = fn.prototype;
    // result接收构造函数执行后的返回结果，this指向obj
    result = arguments.length>0?fn.apply(obj,arguments):fn.apply(obj);
    // fn返回的是一个值的时候，会忽略那个值，返回一个对象时，会返回这个对象
    // 如果构造函数返回一个对象，则将该对象返回，否则返回步骤1创建的对象
    return typeof result === 'object'?result:obj;
  }
```
对于构造函数通过new创建一个新实例对象，在内存上开辟了一个新空间，同时将实例对象的proto属性指向构造函数的prototype原型对象。并且将构造函数的属性通过this指向new创建出的实例对象。判断函数的返回值类型，如果是值类型就返回创建的对象，如果是引用类型就返回引用类型对象。
##### 51.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
hasOwnProperty方法，该方法用于查找对象身上自身特点的属性，而不去查找原型上的属性，会将原型上的属性忽略掉。
##### 52.对于 JSON 的了解？
JSON是一种基于文本的轻量级的数据交换格式，它可以被任何编程语言读取并交换数据格式。

在项目开发中我们常用JSON来进行前后端数据的传递，我们在前端将数据转换为JSON字符串的格式传递给后端，后端接收到数据后通过将其转换为特定的数据结构来进行处理。

因为JSON是基于js语法的，但两者有很大差别，JSON格式更为严格，例如不能使用方法属性，且属性用双引号。

js中提供了两种方法来对JSON格式进行处理，一是JSON.stringify将JSON数据结构转变为JSON字符串的模式。

二是JSON.parse方法将JSON字符串格式转变为js数据结构，若接收到的数据不是JSON字符串格式就会报错，例如我们在后端接收到JSON字符串格式的数据，可以通过JSON.parse将其转变为js数据结构再进行数据处理。
##### 53.能解释一下这段代码的意思吗？
```js
[].forEach.call($$('*'),function(a){
    a.style.outline = "1px solid #"+(~~(Math.random()*(1<<24))).toString(16);
})
```
选中页面所有元素为其添加一个1px随机颜色的边框
  - 选择页面中的所有元素：$$() 函数是现代浏览器提供的一个命令行 API ，它相当于 `document.querySelectorAll()`，可以将当前页面中的 CSS 选择器作为参数传递给此方法，然后它会返回匹配的所有元素。
  - 遍历元素：`[].forEach.call($$('*'),function(a){...})`;  通过使用函数的 call 和 apply 方法进行方法借用，可以实现类似 NodeList 这样的类数组对象上调用数组方法。
  - 为元素添加颜色：a.style.outline="1px solid #"+color ，代码中使用 outline 的 CSS 属性给元素添加一个边框，由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。
  - 生成随机颜色：`(~~(Math.random()*(1<<24))).toString(16) `
  `Math.random()*(1<<24)` 可以得到 0~2^24 -1 之间的随机数，使用了位操作。<< 是左位移操作符

  - 因为得到了一个浮点数，但是我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，使用两个波浪号等价于使用 parseInt：`const a = 12.23;  ~~a === parseInt(a); //true`
  - 然后再用 `toString(16) `方式，转换成一个十六进制的字符串。toString() 方法将数值转换为字符串时，接收一个参数用以指明数值的进制。如果省略了该参数，则默认采用十进制，但可以指定为其他进制。例如十六进制。
##### 54. js 延迟加载的方式有哪些？CSS阻塞？
js代码在解析和执行时会阻塞页面的渲染，阻碍dom向下执行，因此我们希望能够延迟js加载，从而使页面性能更好更加流畅。
  - js阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。
  - 根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。

延迟加载
  - 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。
  - 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。
  - 使用defer（只支持IE）表面页面自上而下执行时若遇到js脚本时不会阻塞页面向下执行，而是加载js脚本和页面解析同时进行，当页面元素全部解析完毕时再按照js脚本的顺序执行js语句。
  - 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用`setTimeout`来调用
  - 可以使用动态创建script标签的方式，我们可以对文档的加载事件进行监听，当页面元素全部加载完毕时再动态创建script标签，进行外部js脚本的外链。
  - 可以通过在script标签添加async属性，它和defer属性的不同是等到js脚本加载完毕就回过头去执行js代码，而不会等到所有页面元素加载完毕，是异步进行的，js脚本不会按照顺序执行，哪个先加载完毕就先执行哪个js代码。
```js
动态加载js
<script>
var script=document.createElement("script");
script.type="text/javascript";
script.src="file.js";
document.getElementsByTagName("head")[0].appendChild(script);
</script>
```

##### 55.Ajax 是什么? 如何创建一个 Ajax？
Ajax属于异步通信，通过XMLHTTPRequest创建xhr，从服务器xml文档中获取数据，并更新到页面局部，不必刷新整个页面。
```js
function ajax(options){
   //设置默认对象 
    var defaults = {
        type: 'get',
        url: '',
        data: {},
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        success: function(){},
        error: function(){}
    };
    //将传入参数对象与默认对象合并
    Object.assign(defaults, options);
    var params = '';
    for(let attr in defaults.data){
        params += attr + '=' + defaults.data[attr] + '&';
    }
    params = params.substr(0, params.length);
    if(defaults.type == 'get'){
        default.url = default.url + '?' + params;
    }
    var xhr = new XMLHTTPRequest();
    xhr.open(defaults.type, defaults.url);
    if(defaults.type == 'post'){
        var contentType = defaults.headers['Content-Type'];
        xhr.setResquestHeader('Content-Type', contentType);
        if(contentType == 'application/json'){
            xhr.send(JSON.stringify(defaults.data));
        } else {
            xhr.send(params);
        }    
    } else {
        xhr.send();
    }
    xhr.onload = function(){
        var contentType = xhr.getResquestHeader('Content-Type');
        var responseText = xhr.responseText;
        if(contentType.includes('application/json')){
            responseText = JSON.parse(responseText);
        }
        if(xhr.status == 200){
            defaults.success(responseText, xhr);
        } else {
            defaults.error(responseText, xhr);
        }
    }
}
```
##### 56. 谈一谈浏览器的缓存机制？
浏览器的缓存机制指的是浏览器能够在一定时间内保存接收到的web资源的副本，当在有效事件内，如果浏览器再次发起相同请求，则直接从缓存中获取数据，不必再向服务器端请求。有效的缓解了服务器端压力以及加快了性能

缓存机制可以分为强缓存和协商缓存。如果为强缓存，在缓存有效时间内，可以直接从缓存中获取资源，不必向服务器端发起请求。强缓存有效时间可以通过设置http头部中的`expries`和`cache-control`来设置。**expries是http1.0中的属性**，它通过设置服务器端绝对时间来控制缓存的有效时间，**但它的缺点是浏览器端和服务器端可能时间不一致，这就导致了缓存有效时间的误差**。可以通过http1.1中的cache-control来控制，它提供了很多不同的控制信息，例如max-age用来指定缓存有效最大时间，这是一个相对时间，相比于第一次浏览器端请求，过了一定时间后缓存失效。还有private用来控制缓存只能被客户端获取，不能被代理服务端获取。还有no-store表示资源不能被缓存，no-cache表示可以被缓存但是会立即失效，每次都要向服务器端发起请求。cache-control的优先级大于expries。

协商缓存策略是浏览器首先向服务器端发送请求，若请求内容和条件自上次请求以来没有发生修改则返回304状态码，如果发生了修改则返回最新修改的资源。协商缓存也可以通过两种方式来设置，第一个是通过设置响应头中的`last-modify`属性，返回了资源最后一次修改时间，当浏览器再次发起请求时请求头中会带有`if-modify-since`属性，属性值即为`last-modify`的值，服务器将获取到的这个头部值与最后一次修改资源的时间进行比较，若发生修改则返回新的资源，若没有修改则告知浏览器使用缓存中的内容。但这个方式有缺陷就是`last-modify`的值只能精确到秒级，如果某些资源在一秒之内修改多次，那么文件发生了修改而`last-modify`没有发生改变。因此第二种方式是通过设置响应头中的`ETag`值，它保存了资源的唯一标识符，当资源发生修改时，`ETag`也会发生改变。当浏览器端向服务器端发起请求时，会在请求头中添加`if-none-match`头部，值为返回的`ETag`值，服务器端会根据这个值与对应文件的ETag值进行对比判断是否发生了修改。当这两个方法同时设置时，`ETag`的优先级会高于`last-modify`。

强缓存和协商缓存都是当缓存命中时直接使用缓存文件，**区别是协商缓存需要先向服务器端发起一次请求**。当强缓存命中时会直接使用缓存资源，若未命中则向服务器端发起请求，**使用协商缓存，若协商缓存命中则告知浏览器使用缓存资源，若未命中则将最新修改过后的资源返回给浏览器端**。

web缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN缓存）、浏览器缓存。
浏览器端缓存包括：HTTP缓存、indexDB、cookie、localstorage
四个术语：缓存命中率、过期内容、验证、失效
浏览器第一次请求（无缓存、向web服务器请求、请求响应、缓存协商【第二次用】）

强缓存：浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
1. 浏览器先根据这个资源http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。强
2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。协商
3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。

命中强缓存，浏览器并不会将请求发送给服务器，http200，size会显示from cache。利用返回头中expires和cache-control，expire绝对时间，客户端和服务端时间不一致就会造成误差。

协商缓存：若未命中强缓存，则浏览器会将请求发送至服务器，服务器根据http头信息中的`if-modify-since`（精度问题）和`ETag`来判断是否命中协商缓存，如果命中，则返回304，浏览器从缓存中加载资源。

强缓存优势：提高并发效率,很多资源不需要重复请求直接从浏览器中拿缓存。


##### HTTP请求
当我们在web浏览器中输入一个网址发生了什么？
  1. 对这个网址进行DNS域名解析，得到对应的ip地址
  2. 根据这个ip地址，找到服务器，发起TCP的三次握手
  3. 建立TCP连接后发起HTTP请求
  4. 服务器响应HTTP请求，浏览器得到HTML代码
  5. 浏览器解析HTML代码，并请求代码中资源（js、css、图片，先得到html代码后才能去找这些资源）
  6. 浏览器对页面进行渲染呈现给用户
  7. 服务器关闭TCP连接
注：tcp是比http更底层的一个连接协议，http是应用层的，tcp是传输层
DNS怎么找到域名的，采取递归查询的方式，浏览器缓存-系统缓存-host，缓存找不到就递归找根域名服务器，根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器。
- 为什么HTTP协议要基于TCP来实现？
TCP是一个端到端的可靠的面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当错误发生时，会重传，TCP有状态，HTTP无状态）
- 最后一步浏览器是如何对页面进行渲染的？
解析html文件构成DOM树，解析CSS文件构成CSSOM树，执行js，根据dom树和cssom树生成渲染树，渲染树是按顺序展示在屏幕上的一系列矩形，这些矩形带有字体颜色和尺寸视觉属性，根据渲染树节点树每一个节点布局在屏幕上正确位置，遍历渲染树绘制所有节点，为每一个节点适用对应的样式，通过UI后端模块完成
- 一般情况下，一旦web服务器向浏览器发送了请求数据，它就要关闭tcp连接，然后如果浏览器或者服务器在头信息加入了Connection：keep-alive TCP连接在发送后仍然保持打开状态，羽是浏览器可以继续通过相同的连接发送请求，保持连接节省了为每个请求建立新连接所需的事件，节约了网络带宽。
- 三次握手本质就是确认通信双方收发数据的能力
- HTTP1.0 短连接，拿到html就断开，分析html后再去依次建立tcp去拿css js 图片等信息
- HTTP1.1 默认长连接（keep-alive）
- SSL（安全套接层）标准化之后改名TLS（传输层安全协议）HTTPS是HTTP over SSL，应用层下面加了一个安全层。
- CA证书，增加窃听成本，还是解决不了窃听问题，只是相对安全
- [HTTPS、TLS](https://blog.csdn.net/freekiteyu/article/details/76423436)
- [TCP、HTTP各种状态码](https://blog.csdn.net/ThinkWon/article/details/104903925)
