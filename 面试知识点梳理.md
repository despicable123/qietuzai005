## 防抖节流
- 本质上是优化高频率执行代码的一种手段
- 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
- 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率
- 定义：节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次执行    场景：resize、scroll、mousemove
        防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时  场景：实时搜索联想
# 节流
```js
// 用来返回节流函数的工具函数
function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        //不传递this的话会丢失this指向
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn.apply(context, args), remaining);
        }
    }
}
```

# 防抖
```js
function debounce(calllback, delay) {
  return function() {
    //启动定时器，只是准备真正处理
    if(callback.hasOwnProperty('timeoutId'){
      clearTimeout(callback.timeoutId)
    })
    callback.timeoutId = setTimeout(()=>{
      callback.apply(this,arguments)
      //标记事件已经正在处理
      delete callback.timeoutId // 或者 clearTimeout(callback.timeoutId)
    },delay)
  }
}
```

## webpack
- 一切文件皆为模块，都有依赖关系
- 从入口文件开始，递归找到所有文件依赖模块，内部构建一个依赖图，依赖图会映射项目所需的每个模块，并生成一个或多个bundle文件
- webpack与webpack-cli在4.0之后的区别（webpack做js的打包工作，-cli解析webpack命令，命令内部使用webpack功能）
- webpack不用全局下载，只需要局部下载即可：原因公司多个项目可能使用不同版本的webpack
- 使用npx webpack使用局部webpack进行打包，
- 使用npm script运行的webpack命令默认先找的是局部的webpack
- webpack本身能解析打包各种模块规范的js代码（ES6、CommonJS、AMD、CMD）
- 核心概念（模式、入口、输出、加载器、插件）
# 处理
1. loader处理
2. plugin处理
3. devtool
4. devSever
# 搭建环境
1. 基础环境
2. vue环境
3. react环境

## XSS（跨站脚本攻击）
1. 通过html注入篡改了网页，插入了恶意的脚本，反射型xss、存储型xss、dom based xss
2. XSS payload，xss攻击成功后往页面植入恶意脚本，这些脚本被称为xss payload，常见的是通过读取浏览器的cookie对象，发起cookie劫持，构造get post请求、构造技巧，利用字符编码，window.name可以跨域，为了绕过长度限制，藏代码最好地方是location.hash，用eval执行
3. 防御xss：httpOnly，服务器返回时发送Set-Cookie头，向客户端写入Cookie，httpOnly在此时标记，不允许客户端脚本访问。输入输出检查。

## CSRF （跨站点请求伪造）
1. 诱使用户访问一个页面，以该用户身份在第三方站点里执行一次操作，伪造请求这种攻击就叫做跨站点请求伪造。
2. 浏览器Cookie策略，两种Cookie：Session Cookie（临时Cookie，保存浏览器进程的内存空间）和Third-party Cookie（本地Cookie，保存在本地）
3. 本地Cookie设置了过期时间，到期才失效，临时Cookie关浏览器就没了，ie禁止浏览器在img、iframe、script、link标签中发送本地Cookie，但是p3p头允许跨域设置Cookie，p3p策略是一一对应的
4. CSRF的防御：
   - 验证码：CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码强制用户和应用进行交互，才能完成最终请求。但是不能给所有请求都加验证码，是一种辅助手段。
   - Refer Check：最常见的应用是防止图片盗链，用于检查请求是否来自合法的源，比如论坛发帖操作，提交发帖表单时，Refer值必然时发帖表单所在的页面，如果refer值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。缺陷在于，服务器并非上面时候都能取到referer，很多用户处于隐私保护的考虑，限制了refer的发送，在某些情况下，比如HTTPS跳转HTTP，出于安全考虑，浏览器不会发送Refer。
   - token：要真随机数，尽量存在服务器端的session中，防止出现在referer中，用POST请求，此方案仅用于对抗CSRF，如果网站还存在XSS漏洞token会被访问到然后再构造除一个合法的请求，这个过程可以称为XSRF。

## Oath
1. A网站想获取用户在B平台的信息，引导用户访问B平台的授权页面。
2. 用户同意授权后重定向至A网站，A后台获取一个code，拿code去B平台换取access_token和用户id，access_ token和用户id去换取用户信息。


## cookie、session、jwt、token
1. http是无状态的，上面的方式其实都是为了让客户端-服务端进行有状态的对话。
2. cookie+session坏处是session存在内存中，服务端重启后所有用户都需要重新登录。浏览器禁用cookie之后回造成用户会话永久失效，因为发起请求中没有cookie，服务端无法识别用户，用nignx做负载均衡集群的时候，登录session存在a服务器，请求发到b服务器去的时候就无法验证，需要用户重新登录，虽然可以用ip hash解决这个问题，但是负载均衡就失去意义了。好处是浏览器都内置了对cookie seesion的处理，不需要后端及前端开发人员理解交互逻辑，一个api即可完成认证，服务端可以控制cookie+session机制的有效会话事件
3. cookie+session更适合于单体web服务，在前后端不分离的项目用的比较多