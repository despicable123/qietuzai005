## 防抖节流
- 本质上是优化高频率执行代码的一种手段
- 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
- 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率
- 定义：节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次执行    场景：resize、scroll、mousemove
        防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时  场景：实时搜索联想
# 节流
```js
// 用来返回节流函数的工具函数
function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        //不传递this的话会丢失this指向
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn.apply(context, args), remaining);
        }
    }
}
```

# 防抖
```js
function debounce(calllback, delay) {
  return function() {
    //启动定时器，只是准备真正处理
    if(callback.hasOwnProperty('timeoutId'){
      clearTimeout(callback.timeoutId)
    })
    callback.timeoutId = setTimeout(()=>{
      callback.apply(this,arguments)
      //标记事件已经正在处理
      delete callback.timeoutId // 或者 clearTimeout(callback.timeoutId)
    },delay)
  }
}
```

## webpack
- 一切文件皆为模块，都有依赖关系
- 从入口文件开始，递归找到所有文件依赖模块，内部构建一个依赖图，依赖图会映射项目所需的每个模块，并生成一个或多个bundle文件
- webpack与webpack-cli在4.0之后的区别（webpack做js的打包工作，-cli解析webpack命令，命令内部使用webpack功能）
- webpack不用全局下载，只需要局部下载即可：原因公司多个项目可能使用不同版本的webpack
- 使用npx webpack使用局部webpack进行打包，
- 使用npm script运行的webpack命令默认先找的是局部的webpack
- webpack本身能解析打包各种模块规范的js代码（ES6、CommonJS、AMD、CMD）
- 核心概念（模式、入口、输出、加载器、插件）
### 处理
1. loader处理
2. plugin处理
3. devtool
4. devSever
### 搭建环境
1. 基础环境
2. vue环境
3. react环境

## XSS（跨站脚本攻击）
1. 通过html注入篡改了网页，插入了恶意的脚本，反射型xss、存储型xss、dom based xss
2. XSS payload，xss攻击成功后往页面植入恶意脚本，这些脚本被称为xss payload，常见的是通过读取浏览器的cookie对象，发起cookie劫持，构造get post请求、构造技巧，利用字符编码，window.name可以跨域，为了绕过长度限制，藏代码最好地方是location.hash，用eval执行
3. 防御xss：httpOnly，服务器返回时发送Set-Cookie头，向客户端写入Cookie，httpOnly在此时标记，不允许客户端脚本访问。输入输出检查。

## CSRF （跨站点请求伪造）
1. 诱使用户访问一个页面，以该用户身份在第三方站点里执行一次操作，伪造请求这种攻击就叫做跨站点请求伪造。
2. 浏览器Cookie策略，两种Cookie：Session Cookie（临时Cookie，保存浏览器进程的内存空间）和Third-party Cookie（本地Cookie，保存在本地）
3. 本地Cookie设置了过期时间，到期才失效，临时Cookie关浏览器就没了，ie禁止浏览器在img、iframe、script、link标签中发送本地Cookie，但是p3p头允许跨域设置Cookie，p3p策略是一一对应的
4. CSRF的防御：
   - 验证码：CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码强制用户和应用进行交互，才能完成最终请求。但是不能给所有请求都加验证码，是一种辅助手段。
   - Refer Check：最常见的应用是防止图片盗链，用于检查请求是否来自合法的源，比如论坛发帖操作，提交发帖表单时，Refer值必然时发帖表单所在的页面，如果refer值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。缺陷在于，服务器并非上面时候都能取到referer，很多用户处于隐私保护的考虑，限制了refer的发送，在某些情况下，比如HTTPS跳转HTTP，出于安全考虑，浏览器不会发送Refer。
   - token：要真随机数，尽量存在服务器端的session中，防止出现在referer中，用POST请求，此方案仅用于对抗CSRF，如果网站还存在XSS漏洞token会被访问到然后再构造除一个合法的请求，这个过程可以称为XSRF。

## Oath
1. A网站想获取用户在B平台的信息，引导用户访问B平台的授权页面。
2. 用户同意授权后重定向至A网站，A后台获取一个code，拿code去B平台换取access_token和用户id，access_ token和用户id去换取用户信息。


## cookie、session、jwt、token
1. http是无状态的，上面的方式其实都是为了让客户端-服务端进行有状态的对话。
2. cookie+session坏处是session存在内存中，服务端重启后所有用户都需要重新登录。浏览器禁用cookie之后回造成用户会话永久失效，因为发起请求中没有cookie，服务端无法识别用户，用nignx做负载均衡集群的时候，登录session存在a服务器，请求发到b服务器去的时候就无法验证，需要用户重新登录，虽然可以用ip hash解决这个问题，但是负载均衡就失去意义了。好处是浏览器都内置了对cookie seesion的处理，不需要后端及前端开发人员理解交互逻辑，一个api即可完成认证，服务端可以控制cookie+session机制的有效会话事件
3. cookie+session更适合于单体web服务，在前后端不分离的项目用的比较多。
4. jwt
   - 优点是无状态去中心化的，支持移动设备，支持跨程序调用，cookie是不允许跨域访问的，加密特性保证了token不可伪造和篡改。
   - 缺点是jwt仅在生成时支持失效时间，失效时间固定，不可主动失效，不可存储大量信息。

##### 1.js基本数据类型
js的基本数据类型有字符型、数值型、布尔值、null、undefined和es6新增的symbol。symbol主要作用是给变量提供唯一的标识，可以解决全局变量冲突的问题。
##### 2.JavaScript 有几种类型的值？你能画一下他们的内存图吗？
栈：基本数据类型

堆：引用数据类型

两者区别在三个方面：

声明变量时不同内存位置不同：基本数据类型变量的值储存在栈中，这是因为基本数据类型占据的空间内存是固定的，因此可以直接访问。引用数据类型储存在栈中的是变量的地址指针，指向堆中的引用。因为引用数据类型的大小会改变因此不能储存在栈中会影响查找的速率。

访问机制不同：在JavaScript中是不允许直接访问储存在堆内存中的变量的，能够访问的是堆内存中的地址，然后按照地址去访问引用类型，而栈中的数据变量是可以直接访问到的。

复制变量时不同：栈中的变量复制时会将数值保存为另一个副本，这两者是相互独立的。而堆中的对象进行复制时是将保存着内存地址的变量赋值给另一个变量，两者引用地址相同，它们中任何一个进行修改时都会改变另一个变量。

传递参数时不同：传递参数是将变量的值传递给形参，引用数据类型中的值为该变量在堆内存中的地址，因此将引用数据类型作为参数传递时在函数内部对变量进行修改会影响函数外部该引用数据的值。
##### 3.什么是堆？什么是栈？它们之间有什么区别和联系？
栈和堆的概念来自于从数据结构和操作系统中。

数据结构中栈为先进后出队列，而堆为优先级队列，二叉树为典型的堆队列。

操作系统中栈区内存由编译器自动释放，主要储存函数的参数、局部变量等，结束后自动销毁。堆区内存主要靠程序员手动释放，若没有手动释放，垃圾回收机制会将其回收。
##### 4.内部属性 [&#91;Class]] 是什么？
所有用typeof返回为object的变量都含有一个内部属性[&#91;Class]]，可以看成是内部的分类，利用Object.prototype.toString.call()可返回该分类。

例如Object.prototype.toString.call([]) 返回[&#91;Object Array]]
##### 5.介绍 js 有哪些内置对象？
js中的内置对象指的是在操作前由js定义的存在于全局作用域中的全局值属性、函数对象、以及可实例化的构造函数。全局值属性例如NaN、null等，函数有parseInt、parseFloat等，可实例化其他对象的构造函数Number、Boolean、Function等以及还有Date、数学对象Math等。
##### 6.undefined 与 undeclared 的区别？
已在全局中声明但还没有赋值的变量返回undefined，未声明的变量是undeclared。会报错返回is not defined。
#####  7.null 和 undefined 的区别？
null表示这个值被定义了但是这个值是空值，是对象原型链的终点，undefined表示缺值。Number(null)输出为0, Number(undefined)输出为NaN

首先null和undefined都是基本数据类型。

undefined表示变量未定义，null代表的含义是空对象，一般变量未定义的时候会返回undefined，null一般作为变量对象的初始值。

typeof null 会返回object。null == undefined 返回true，但三个等号返回false。
##### 8.如何获取安全的 undefined 值？
表达式void _ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。
按惯例我们用void 0来获得 undefined。
##### 9.说几条写 JavaScript 的基本规范？
在日常书写JavaScript代码时应该遵循一些基本规范利于读者阅读以及日后维护。例如：

变量声明尽量放在作用域的前面，并且var声明时最好给予初始值。

用===和!&#61;=来代替&#61;=和！=。

不要给内置对象的原型对象上添加方法，例如Array，Object，Function等。

代码中出现地址、时间等常量用变量来代替。

switch语句必须带有default分支。

if和for语句要有大括号。
##### 10.JavaScript 原型，原型链？ 有什么特点？
在JavaScript中我们使用构造函数创建一个实例对象时，每个构造函数内部都有一个prototype属性，这个属性是一个对象，即原型对象。实例对象内部的 proto 属性指向构造函数的原型对象，并且该原型对象也可看成其他构造函数的实例，这个proto属性链就是原型链。当我们要查找实例对象身上的某个属性及方法时，若该实例对象身上没有，可沿着proto属性一级一级向上找，直至Object.prototype。

特点：JavaScript中是利用引用来进行传递的，当我们修改了某一原型的属性时，所有继承都会被修改。
##### 11.js 获取原型的方法？
- P.constructor.prototype
- Object.getPrototypeOf(P)
- P.proto
##### 12.在 js 中不同进制数字的表示方式
- 以 0X、0x 开头的表示为十六进制。
- 以 0、0O、0o 开头的表示为八进制。
- 以 0B、0b 开头的表示为二进制格式。
#####  13.js 中整数的安全范围是多少？
JS 中所有的数字类型，实际存储都是通过 8 字节 double 浮点型 表示的。安全整数指的是该整数转换为二进制时精度不会丢失。最大值指的是2的53次幂-1，超过安全整数范围在计算时会有误差。在ES6中被定义为Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER。当超过整数范围时会返回infinity。
##### 14.typeof NaN 的结果是什么？
typeof NaN会返回number。NaN是一个特殊值，它与自身不相等，NaN !=NaN 为true
#####  15.isNaN 和 Number.isNaN 函数的区别？
isNaN接收参数时会尝试将其转化为数值型再判断，因此传入的不能转换为数值的会返回true，但非数值型也会返回true，影响了NaN的判断。

Number.isNaN会先判断其是否为Number，然后在进行isNaN判断。判断更为准确。
##### 16.Array 构造函数只有一个参数值时的表现？
Array构造函数只有一个参数值时会让其视为创建数组的长度length值，而非充当一个元素。但创建出来的数组依然是个空数组，但有预设长度值。
##### 17.其他值到数字值的转换规则？
undefined返回NaN。
null返回0.
true返回1，false返回0.
字符串类型的值转换为数值型如同利用Number()，若字符串中含有非数字型返回NaN，空字符串返回0.
##### 18.其他值到布尔类型的值的转换规则？
转换为false的有六种：
null、undefined、false、""、NaN、+0、-0
#####  19.{} 和 [] 的 valueOf 和 toString 的结果是什么？
{}的valueOf为{}，toString为[Object Object]
[] 的valueOf为 [], toString为“”
##### 20.什么是假值对象？
在某些情况下，浏览器在一些常规的JavaScript基础上自行创建的一些对象，这些对象强制转换为布尔值时为false，例如document.all为一个伪数组，表示页面中所有元素的数组，由DOM提供给JavaScript使用。
##### 21.~ 操作符的作用？
~表示按位取反，~~可以用于取整。
##### 22.解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？
解析字符串中的数字允许含有非数字，例如parseInt解析字符串时会返回开头的数值，若第一个字符为非数字，则返回NaN，而Number（）解析字符串时字符中不能含有不合法字符。否则返回NaN.
##### 23.其他值到字符串的转换规则？
toString（）
##### 24.+ 操作符什么时候用于字符串的拼接？
当+操作符前后两个变量至少一个为字符串时，两者用+连接为字符串拼接。若两者都为数字，则会数字加法运算。而除了+以外的其他运算符，只要其中一方为数字，另一方就会转换为数字。
##### 25. 什么情况下会发生布尔值的隐式强制类型转换？
例如在if语句中进行判断时会转换为布尔值，还有while语句。三项表达式。for（ ； ； ）中的第二项。逻辑运算符||和&&进行判断时。
##### 26. || 和 && 操作符的返回值？
首先会对第一项进行布尔值强制类型转换。

运用||运算符时，当第一项为true，则直接返回true，当第一项为false，则返回第二项的布尔值

运动&&运算符时，当第一项为true，则返回第二项的布尔值，当第一项为false，则直接返回false。
##### 27.Symbol 值的强制类型转换？
symbol值可以进行显性类型转换 但不能进行隐形类型转换 会报错。
symbol值不能转换为数值型，但可以转化为布尔值，不管是显性还是隐性都是true。
##### 28. == 操作符的强制类型转换规则？
- 字符串和数值型进行==比较时，将字符串转换为数值型再进行比较。
- 其他类型跟布尔值进行比较时，先将布尔值转换为数值型，再进行其他比较。
- NaN和本身取==时为false
- null == undefined 为true
- 如果两个操作值都是对象，则需比较两者是否为同一个引用对象。
##### 29. 如何将字符串转化为数字，例如 '12.3b'?
- 使用Number（）方法，但前提是所包含的字符串不包含不合法字符。
- parseInt（）方法，取整。
- parseFloat（）方法，浮点数
- 隐式类型转换
##### 30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?
使用正则表达式方法
```js
function format(number)
{  return number && number.replace(/(\d)(?=(\d{3}+\.))/g, function($1, $2, $3){  return $2 + ',';  }) }
```
?=pattern 表示匹配到pattern的开始位置的字符，例如window(?=95|98|2000|xp)，可以匹配到window2000中的window。
##### 31. 常用正则表达式
##### 32.生成随机数的各种方法？
Math.random() 生成[0, 1) 范围内的随机浮点数。
##### 33. 如何实现数组的随机排序？
1. 随机抽取下标
```js
  function randomsort(arr){  
    var newarr = [];  
    while(arr.length > 0){   
      var index = Math.floor(Math.random()*arr.length);   
      newarr.push(arr[index]);   
      arr.splice(index, 1);  
    }
    return newarr; 
  }
```
2. 洗牌法
```js
  function randomsort(arr){  
    let leng = arr.length,  
    tempindex;  
    for(var i = 0; i < leng; i++){  
      tempindex = Math.floor(Math.random()*(leng - i) + i);  
      [arr[i],arr[tempindex]] = [arr[tempindex],arr[i]] 
    }  
    return arr; 
  }
```
##### 34. javascript 创建对象的几种方式？
1. 字面量
2. 工厂模式
```js
// 工厂函数
function createPerson ( name, age ) {
    var object = new Object();
    object.name = name;
    object.age = age;
    object.getName = function(){
        return object.name;
    }
    return object;
}
```
3. 构造函数模式
```js
function Person( name, age ) {
    this.name = name;
    this.age = age;
    this.getName = function(){ 
        return this.name;
    };
}
```
4. 原型模式
```js
function Dog(){}
  Dog.prototype.name="旺财";
  Dog.prototype.eat=function(){
  alert(this.name+"是个吃货");
  }
  var wangcai =new Dog();
  wangcai.eat();
```
5. 混合模式
```js
function Car(name,price){
  this.name=name;
  this.price=price; 
  }
  Car.prototype.sell=function(){
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");
  }
  var camry =new Car("凯美瑞",27);
  camry.sell();
```
##### 35.JavaScript 继承的几种实现方式？
1. 原型链继承
- 将子构造函数的原型对象指向父构造函数的实例对象，那么子构造函数的实例对象可继承父类上的属性及方法。缺点是创建子类时不能向父类传参，并且父类原型上的所有引用类型可应用到所有实例对象上。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
  } 
  Father.prototype.getName = function(){  
    return this.name; 
  } 
  function Child(skill){  
    this.skill = skill; 
  } 
  Child.prototype = new Father('zhangsan', 20); 
  var child = new Child('dance'); 
  console.log(child.getName());
```

2. 盗用构造函数继承
- 通过在子类中使用对父构造函数使用call方法来调用，并且修改this指针指向子类，同时可以传递参数。优点：避免了引用类型的属性被所有实例共享，也解决了不能传参的问题。缺点是因为方法都在构造函数中定义了，因此每次创建实例时都要创建一遍方法。
```js
function Father(name, age){  
  this.name = name;  
  this.age = age;  
  this.getName = function(){   return this.name;  }  
  this.getAge = function(){   return this.age;  } 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.getName())
```

3. 组合继承
- 结合原型链继承和盗用构造函数继承，二者优点集中起来
```js
function Father(name, age){  
  this.name = name;  
  this.age = age; 
} 
Father.prototype.money = function(){  
  console.log('100000'); 
} 
function Child(name, age, skill){  
  Father.call(this, name, age);  
  this.skill = skill; 
} 
Child.prototype = new Father(); 
Child.prototype.constructor = Child; 
Child.prototype.exam = function(){  
  console.log('i want to have an exam');
} 
var child = new Child('zhangsan', 20, 'dance'); 
console.log(child.money())
```
4. 原型式继承
- 原则上只是进行了一次浅复制，适合不需要单独创建构造函数的场合，但仍然需要在对象间共享信息，包含的引用值时终会在相关对象间共享，跟使用原型模式是一样的。es5增加了Object.creat()方法等同于下面函数。
```js
function creatObj(o){  
  function F(){};  
  F.prototype = o;  
  return new F(); 
} 
  var person = {  name: 'zhangsan',  age: 20 } 
  var person1 = creatObj(person); 
  var person2 = creatObj(person); 
  person1.name = 'lisi'; 
  console.log(person1.name, person2.name);
```
5. 寄生式继承
- 类似原型式继承，创建了一个封装继承过程的函数，该函数在内部以某种方式来增强对象，在考虑对象不是自定义类型和构造函数的情况下，寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。
```js
function object(o){
    function F() {}
    F.prototype = o;
    return new F();
}
function createAnother(original){
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式来增强这个对象
        console.log("Hi");
    };
    return clone; //返回这个对象
}
var person = {
    name:"李白",
    friends:["杜甫","陆游"]
};
var anotherPerson = createAnother(person)
anotherPerson.sayHi();//Hi
```
6. 寄生式组合继承
- 寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。“寄生组合继承”用了“寄生继承”修复了“组合继承”的小bug，让js完美实现继承了。
```js
// 实现继承的简单方法
function object(o){
function F () {};
F.prototype = o;
return new F();
}
// 寄生继承
function inheritPrototype(subType, superType){
  var prototype = object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}
function testObject() {
var A = function(){}, 
B = function(){}, a, b;
inheritPrototype(B, A)
}
```