### 遇到的困难点
1. keep-alive watch的问题
2. 定时器修改（闭包）
3. 查询返回的mongodb无法修改，为MongooseDocuments对象，对象会对数据进行实时查询以保证其符合预定义的model，所以添加其它model中没有的属性时是无法添加成功的。
4. foreach异步问题
5. 点击穿透上下层

### 微前端
代码库更小，更内聚、可维护性更高
松耦合、自治的团队可扩展性更好
渐进地升级、更新甚至重写部分前端功能成为了可能

简单、松耦合的代码库
比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发
此外，更重要的是避免模块间不合理的隐式耦合造成的复杂度上升。通过界定清晰的应用边界来降低意外耦合的可能性，增加子应用间逻辑耦合的成本，促使开发者明确数据和事件在应用程序中的流向

增量升级
理想的代码自然是模块清晰、依赖明确、易于扩展、便于维护的……然而，实践中出于各式各样的原因：
历史项目，祖传代码
交付压力，当时求快
就近就熟，当时求稳……
总存在一些不那么理想的代码：
所以，为了实施渐进式重构，我们需要一种增量升级的能力，先让新旧代码和谐共存，再逐步转化旧代码，直到整个重构完成
这种增量升级的能力意味着我们能够对产品功能进行低风险的局部替换，包括升级依赖项、更替架构、UI 改版等。另一方面，也带来了技术选型上的灵活性，有助于新技术、新交互模式的实验性试错

独立部署
独立部署的能力在微前端体系中至关重要，能够缩小变更范围，进而降低相关风险
因此，每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），并且要能独立部署，不必过多考虑其它代码库和交付流水线的当前状态：

##### 实现方案
多 Bundle 集成
微前端架构中一般会有个容器应用（container application）将各子应用集成起来，职责如下：
渲染公共的页面元素，比如 header、footer
解决横切关注点（cross-cutting concerns），如身份验证和导航
将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机
集成方式分为 3 类：
服务端集成：如 SSR 拼装模板，如何保证各部分模板（各个微前端）能够独立发布
构建时集成：如 Code Splitting，将子应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle
运行时集成：如通过 iframe、JS(前端路由)、Web Components 等方式,前端路由，每个子应用暴露出渲染函数，主应用在启动时加载各个子应用的独立 Bundle，之后根据路由规则渲染相应的子应用。

影响隔离
子应用之间，以及子应用与主应用间的样式、作用域隔离是必须要考虑的问题，常见解决方案如下：
样式隔离：开发规范（如BEM）、CSS 预处理（如SASS）、模块定义（如CSS Module）、用 JS 来写（CSS-in-JS）、以及shadow DOM特性
作用域隔离：各种模块定义（如ES Module、AMD、Common Module、UMD）

资源复用
应用间通信
测试 :除单元测试、功能测试外，还要有集成测试

###### 缺点
流量负担
独立构建意味着公共资源的冗余，继而增加用户的流量负担
操作/管理上的复杂性
针对各式各样的前端代码库，如何建立质量标准？




### 微信公众号开发
1. 接入
2. 网页授权 OAuth2.0
3. 选用node：事件驱动，异步编程，不为每个客户创建新的线程，仅仅使用一个线程，用户连接，触发一个内部事件，通过非阻塞I/O、事件驱动机制、宏观并行。使用 Node.js，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。不是静态语言，运行时才出错。
4. 

### 微信小程序与vue区别
1. vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。
onLoad：页面加载
一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。
onShow：页面显示  每次打开页面都会调用一次。
onReady：页面初次渲染完成
一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。
对界面的设置如 wx.setNavigationBarTitle请在 onReady之后设置。详见生命周期。
onHide：页面隐藏
当 navigateTo或底部tab切换时调用。
onUnload：页面卸载
当 redirectTo或 navigateBack的时候调用。
数据请求
在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在 created或者 mounted中请求数据，而在小程序，会在 onLoad或者 onShow中请求数据。

2. 数据绑定
vue：vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：
小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。

3. 列表渲染
Page({})  new Vue({})

4. 显示与隐藏元素
vue中，使用 v-if 和 v-show控制元素的显示和隐藏。
小程序中，使用 wx-if和 hidden控制元素的显示和隐藏。
5. 事件处理
vue @event   / v-on:event
小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件(不冒泡)
6. 双向绑定
在vue中，只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时， data中对应的值也会相应改变，这是vue非常nice的一点。
当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data中的对应值。
vue中，通过 this.reason取值。
小程序中，通过 this.data.reason取值
7. 绑定事件传参
在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如
`<button @click="say('明天不上班')"></button>`
在 小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取，从而完成参数的传递
8. 在小程序中，需要：1、编写子组件2、在子组件的 json文件中，将该文件声明为组件,
在需要引入的父组件的 json文件中，在 usingComponents填写引入组件的组件名以及路径
9. vue会给子组件添加一个 ref属性，通过 this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法

#### BLE相关
1. 写数据时，要填入arraybuffer类型数据，ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。你不能直接操作 ArrayBuffer 的内容，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。DataView 视图是一个可以从 二进制ArrayBuffer 对象中读写多种数值类型的底层接口，你可以把返回的对象想象成一个二进制字节缓存区 array buffer 的“解释器”——它知道如何在读取或写入时正确地转换字节码。这意味着它能在二进制层面处理整数与浮点转化、字节顺序等其他有关的细节问题。

### webmail
