## 两数之和

map

```js
var twoSum = function (nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    let cha = target - nums[i];
    if (map.has(cha)) {
      return [map.get(cha), i];
    } else {
      map.set(nums[i], i);
    }
  }
};
```

## 双指针法（有序，数组）

1. 三数之和

```js
var twoSum = function (nums, target) {
  let res = [];
  nums.sort((a, b) => a - b);
  if (nums.length < 3) {
    return [];
  }
  for (let i = 0; i < nums.length; i++) {
    let j = i + 1;
    let k = nums.length - 1;
    // 关键去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    while (j < k) {
      let sum = nums[i] + nums[j] + nums[k];
      if (sum < 0) {
        j++;
      } else if (sum > 0) {
        k--;
      } else {
        res.push(nums[i], nums[j], nums[k]);
        j++;
        k--;
        // 挪动指针就要开始判断是否重复
        while (j < k && nums[j] === nums[j - 1]) {
          j++;
        }
        while (j < k && nums[k] === nums[k + 1]) {
          k--;
        }
      }
    }
  }
  return res;
};
```

2. 合并两个有序数组

```js
var merge = function (nums1, m, nums2, n) {
  let i = m - 1;
  let j = n - 1;
  let k = m + n - 1;
  while (i >= 0 && j >= 0) {
    if (nums1[i] >= nums2[j]) {
      nums1[k] = nums1[i];
      i--;
      k--;
    } else {
      nums1[k] = nums2[j];
      j--;
      k--;
    }
  }
  while (j >= 0) {
    nums1[k] = nums2[j];
    j--;
    k--;
  }
};
```

## 无重复最长子字符串(滑动窗口)

```js
var lengthOfLongestSubstring = function (s) {
  let temp = [];
  let i = 0;
  let res = 0;
  while (i < s.length) {
    if (temp.indexOf(s[i]) != -1) {
      temp.shift();
    } else {
      temp.push(s[i]);
      i++;
    }
    res = Math.max(res, temp.length);
  }
  return res;
};
```

## 排序两个有序链表

```js
var mergeTwoLists = function (l1, l2) {
  let head = new ListNode();
  let cur = head;
  while (l1 && l2) {
    if (l1.val >= l2.val) {
      cur.next = l2;
      l2 = l2.next;
    } else {
      cur.next = l1;
      l1 = l1.next;
    }
    cur = cur.next;
  }
  if (l1) {
    cur.next = l1;
  }
  if (l2) {
    cur.next = l2;
  }
  return head.next;
};
```

## 链表节点的删除

```js
var deleteNode = function (head, val) {
  let pre = new ListNode(-1); // 哨兵节点
  pre.next = head;
  let node = pre.next;
  while (node.next) {
    if (node.next.val === val) {
      node.next = node.next.next;
      break;
    } else {
      node = node.next;
    }
  }
  return pre.next;
};
```

## 删除链表重复节点(有序)

```js
var deleteNode = function (head) {
  let pre = new ListNode(-1);
  pre.next = head;
  let cur = pre.next;
  while (cur && cur.next) {
    if (cur.val === cur.next.val) {
      cur.next = cur.next.next;
    } else {
      cur = cur.next;
    }
  }
  return pre.next;
};
```

## 重复的删干净

```js
var deleteDuplicates = function (head) {
  if (!head || !head.next) return head;
  let pre = new ListNode(-1);
  pre.next = head;
  let cur = pre;
  while (cur.next && cur.next.next) {
    if (cur.next.val === cur.next.next.val) {
      let val = cur.next.val;
      while (cur.next && cur.next.val === val) {
        cur.next = cur.next.next;
      }
    } else {
      cur = cur.next;
    }
  }
  return pre.next;
};
```

## 删除链表第 N 个节点

```js
var removeNthFromEnd = function (head, n) {
  let pre = new ListNode(-1);
  pre.next = head;
  let fast = pre;
  let slow = pre;
  while (n > 0) {
    fast = fast.next;
    n--;
  }
  //快指针到倒数第二个节点，才能保证慢指针不走过
  while (fast.next) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return pre.next;
};
```

## 链表反转

```js
var reverseList = function (head) {
  let pre = null;
  let cur = head;

  while (cur) {
    let next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
};
```

## 链表局部反转

```js
const reverseBetween = function (head, m, n) {
  let dummy = new ListNode(-1);
  let cur = head;
  let headLeft;
  let pre;
  dummy.next = head;
  let p = dummy;
  for (let i = 0; i < m - 1; i++) {
    p = p.next;
  }
  headLeft = p;
  let start = headLeft.next;
  pre = start;
  cur = pre.next;
  for (let i = m; m < n; i++) {
    let temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  headLeft.next = pre;
  start.next = cur;
  return dummy.next;
};
```

## 判断有环

```js
var hasCycle = function (head) {
  if (!head || !head.next) {
    return false;
  }

  let slow = head;
  let fast = head;
  //  动两格就while到一格
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true;
    }
  }
};
```

```js
var hasCycle = function (head) {
  while (head) {
    if (!head.flag) {
      head.flag = true;
      head = head.next;
    }
    return true;
  }
  return false;
};
```

## 判断环在哪里

```js
var detectCycle = function (head) {
  while (head) {
    if (!head.flag) {
      head.flag = true;
      head = head.next;
    } else {
      return head;
    }
  }
  return null;
};
```

## 深搜索

```js
var city = [
  {
    code: 0,
    name: "beijing",
  },
  {
    code: 211,
    name: "jiangsu",
    children: [
      {
        code: 212,
        name: "nanjing",
      },
    ],
  },
];
function search(code) {
  let name;
  function searchObj(code, obj) {
    for (let key in obj) {
      let value = obj[key];
      if (key === "code" && value === code) {
        name = obj["name"];
        return;
      } else {
        if (typeof value === "object") {
          searchObj(code, value);
        }
      }
    }
  }
  searchObj(code, city);
  return name;
}
console.log(search(211));
```

## 数组去重

```js
//两重循环
function unique(arr) {
  const newArray = [];

  for (let i = 0; i < arr.length; i++) {
    let isRepeat = false;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        isRepeat = true;
      }
    }
    if (!Repeat) {
      newArray.push(arr[i]);
    }
  }
  return newArray;
}
```

```js
//reduce
function unique(arr) {
  arr.reduce((l, r) => {
    if (l.indexOf(r) === -1) {
      l.push(r);
    }
    return l;
  }, []);
}
```

```js
//map
function unique(arr) {
  const map = new Map();
  let newArray = [];
  for (let i = 0; i < arr.length; i++) {
    if (!map.has(arr[i])) {
      map.set(arr[i], i);
      newArray.push(arr[i]);
    }
  }
  return newArray;
}
```

```js
//set
[...new Set(...arr)];
```

```js
//天气
const dailyTemperatures = function (T) {
  const len = T.length; // 缓存数组的长度
  const stack = []; // 初始化一个栈
  const res = new Array(len).fill(0); //  初始化结果数组，注意数组定长，占位为0
  for (let i = 0; i < len; i++) {
    // 若栈不为0，且存在打破递减趋势的温度值
    while (stack.length && T[i] > T[stack[stack.length - 1]]) {
      // 将栈顶温度值对应的索引出栈
      const top = stack.pop();
      // 计算 当前栈顶温度值与第一个高于它的温度值 的索引差值
      res[top] = i - top;
    }
    // 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算
    stack.push(i);
  }
  // 返回结果数组
  return res;
};
```

## 计算器

```js
var calculate = function (s) {
  let stack = [];
  let signal = "+";
  let n = 0;
  s = s.split("");
  //遍历到最后一个undefined  = 不能少
  for (let i = 0; i <= s.length; i++) {
    if (s[i] == " ") continue;
    if (s[i] >= "0" && s[i] <= "9") {
      n = n * 10 + parseInt(s[i]);
      continue;
    }
    if (signal === "+") {
      stack.push(+n);
    } else if (signal === "-") {
      stack.push(-n);
    } else if (signal === "*") {
      stack.push(stack.pop() * n);
    } else if (signal === "/") {
      stack.push(Math.trunc(stack.pop() / n));
    }
    signal = s[i];
    n = 0;
  }
  return stack.reduce((l, r) => l + r, 0);
};
```

## N 叉树前序遍历

```js
var preorder = function (root) {
  if (!root) return [];
  let res = [];
  let stack = [];
  stack.push(root);
  while (stack.length) {
    let top = stack.pop();
    res.push(top.val);
    if (top.children) {
      top.children.reverse().forEach((child) => {
        stack.push(child);
      });
    }
  }
  return res;
};
```

## 二叉树层序遍历

```js
var levelOrder = function (root) {
  if (!root) return [];
  let quene = [];
  quene.push(root);
  let res = [];
  while (quene.length) {
    let arr = [];
    let length = quene.length;
    while (length--) {
      let top = quene.shift();
      arr.push(top.val);
      if (top.left) quene.push(top.left);
      if (top.right) quene.push(top.right);
    }
    res.push(arr);
  }
  return res;
};
```

## N 叉树层序遍历

```js
var levelOrder = function (root) {
  if (!root) return [];
  let res = [];
  let queue = [];
  queue.push(root);
  while (queue.length) {
    let arr = [];
    let length = queue.length;
    while (length--) {
      let top = queue.shift();
      arr.push(top.val);
      if (top.children) {
        top.children.forEach((child) => queue.push(child));
      }
    }
    res.push(arr);
  }
  return res;
};
```

## 二叉树的中序遍历

```js
var inorderTraversal = function (root) {
  let stack = [];
  let res = [];
  while (root) {
    stack.push(root);
    root = root.left;
  }
  while (stack.length) {
    let node = stack.pop();
    res.push(node.val);
    node = node.right;
    while (node) {
      stack.push(node);
      node = node.left;
    }
  }
  return res;
};
```

## 二叉树的后续遍历

```js
var postorderTraversal = function (root) {
  let stack = [];
  let res = [];
  if (!root) return [];
  stack.push(root);
  while (stack.length) {
    let top = stack.pop();
    res.unshift(top.val);
    if (top.left) {
      stack.push(top.left);
    }
    if (top.right) {
      stack.push(top.right);
    }
  }
  return res;
};
```

## 快排

```js
var quickSort = function (arr, left = 0, right = arr.length - 1) {
  let partIndex;
  if (left < right) {
    partIndex = part(arr, left, right);
    quickSort(arr, left, partIndex - 1);
    quickSort(arr, partIndex, right);
  }
  return arr;
};
function part(arr, left, right) {
  let i = left;
  let j = right;
  let base = arr[Math.floor(Math.random() * (right - left + 1)) + left];
  while (i <= j) {
    while (arr[i] < base) {
      i++;
    }
    while (arr[j] > base) {
      j--;
    }
    if (i <= j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
      j--;
    }
  }
  return i;
}
```
