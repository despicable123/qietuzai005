## git 命令
* git reflog 查看操作历史
* git checkout -- file 丢弃工作区的修改 使得这个文件回到最近一次git commit或git add时的状态 其实是用版本库里的版本替代工作区的版本
* git checkout - 切换分支  
* git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区

* 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

* 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。

* 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。(git reset --hard HEAD^)HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset * --hard commit_id

* 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

* 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是* 当前分支。

## js对象
1. weakMap：弱映射造就了在js中实现真正私有变量的一种方式（私有变量存储在弱映射中，对象实例为键，私有成员字典为值）
    ```js
    const User = (()=>{
        const wm = new WeakMap()
        class User{
        }
    return User
    })()
    ```
2.	assign 将每个源对象可枚举和自由属性复制到目标对象，使用源对象的get获取属性的值，使用目标对象上的set设置属性的值/
3.	assign不会回滚，尽力而为。
4.	Objectis(a,b)检查超过多个用递归
    ```js
    Function fn(x,…rest){
        return Object.is(x,rest[0]) && (rest.length < 2) || fn(…rest)
    }
    ```
5.	解构在内部使用函数toObject
6.	工厂模式可以解决创建多个类似对象的问题，但没有解决的对象标识问题（即新创建的对象是什么类型）
7.	构造函数模式没有显式创建对象、属性和方法直接复制给this、没有return（构造函数名称的首字母都是要大写的，非构造函数小写字母开头）
8.	没有用new调用的构造函数，属性和方法会被添加到window对象中
9.	函数也是对象，构造函数里的方法每次调用都会初始化一个对象，每个实例都会有自己的方法（）实例。
10.	原型模式下实例共有的方法取等。与构造函数模式不同，使用这种原型定义的属性和方法是由所有实例共享的。
11. Person.prototype.constructor指向Person
12. 构造函数的prototype属性引用原型对象，原型对象有一个constructor属性引用构造函数，构成循环引用
13. 实例用过_proto_链接到原型对象，构造函数通过prototype属性链接到原型对象
14. Object.create(指定继承的原型)
15. 实例添加属性回遮蔽原型对象的同名属性，用delete可以完全删除实例上的这个属性
16. hasOwnProperty（）用于确认某个属性是在实例上还是在原型对象上，实例true
17. in操作符对实例原型都可
18. 原型模式弱化了向构造函数初始化参数的能力，会导致所有实例默认都取得相同的属性值，原型最主要问题源自它的共享特性（实例会共享引用值属性）
19. js没有接口继承，因为函数没有签名
20. 继承实际上是重写了子构造函数的原型，重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型
21. 原型链第二个问题是子类型在实例化时不能给父类型的构造函数传参
22. 盗用构造函数缺点是必须在构造函数中定义方法，因此函数不能重用。字类不能访问父类原型上定义的方法
+ 组合继承，原型链继承原型上的属性和方法，盗用构造函数继承实例属性。父类构造函数始终会被调用两次：1、创建子类原型 2、字类构造函数中调用  
+ 原型式继承 浅复制，引用类型会和子类共享
+ 寄生式继承 思路类似寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。适合主要关注对象，而不在乎类型和构造函数的场景。
+ 寄生式组合继承 取得父类原型的一个副本，将返回的新对象赋值给字类原型 创建对象、增强对象、赋值对象  1、盗用构造函数继承属性 2、寄生式继承方法

